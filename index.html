<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
	"http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">

<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8"/>
  <title>A system for resource deadlock prevention</title>

  <meta name="viewport" content="width=device-width"/>

  <link rel="stylesheet" href="./css/reset.css" type="text/css"/>
  <link rel="stylesheet" href="./css/showoff.css" type="text/css"/>

  <link type="text/css" href="./css/fg.menu.css" media="screen" rel="stylesheet" />
  <link type="text/css" href="./css/theme/ui.all.css" media="screen" rel="stylesheet" />
  <link type="text/css" href="./css/sh_style.css" rel="stylesheet" />

  <script type="text/javascript" src="./js/jquery-1.7.2.min.js"></script>
  <script type="text/javascript" src="./js/jquery.cycle.all.js"></script>
	<script type="text/javascript" src="./js/jquery-print.js"></script>
  <script type="text/javascript" src="./js/jquery.batchImageLoad.js"></script>

  <script type="text/javascript" src="./js/jquery.doubletap-0.1.js"></script>

  <script type="text/javascript" src="./js/fg.menu.js"></script>
  <script type="text/javascript" src="./js/showoff.js"></script>
  <script type="text/javascript" src="./js/jTypeWriter.js"> </script>
  <script type="text/javascript" src="./js/sh_main.min.js"></script>
  <script type="text/javascript" src="./js/core.js"></script>
  <script type="text/javascript" src="./js/showoffcore.js"></script>
  <script type="text/javascript" src="./js/coffee-script.js"></script>

  
    
      <script type="text/javascript" src="./js/sh_lang/sh_cpp.min.js"></script>
    
      <script type="text/javascript" src="./js/sh_lang/sh_c.min.js"></script>
    
  

  
    <link rel="stylesheet" href="./file/custom.css" type="text/css"/>
  

  

  <script type="text/javascript">
  $(function(){
      setupPreso(false, './');
  });
  </script>

</head>

<body>

<a tabindex="0" href="#search-engines" class="fg-button fg-button-icon-right ui-widget ui-state-default ui-corner-all" id="navmenu"><span class="ui-icon ui-icon-triangle-1-s"></span>slides</a>
<div id="navigation" class="hidden"></div>

<div id="help">
  <table>
    <tr><td class="key">z, ?</td><td>toggle help (this)</td></tr>
    <tr><td class="key">space, &rarr;</td><td>next slide</td></tr>
    <tr><td class="key">shift-space, &larr;</td><td>previous slide</td></tr>
    <tr><td class="key">d</td><td>toggle debug mode</td></tr>
    <tr><td class="key">## &lt;ret&gt;</td><td>go to slide #</td></tr>
    <tr><td class="key">c, t</td><td>table of contents (vi)</td></tr>
    <tr><td class="key">f</td><td>toggle footer</td></tr>
    <tr><td class="key">r</td><td>reload slides</td></tr>
    <tr><td class="key">n</td><td>toggle notes</td></tr>
    <tr><td class="key">p</td><td>run preshow</td></tr>
    <tr><td class="key">P</td><td>toggle pause</td></tr>
  </table>
</div>

<div class="buttonNav">
  <input type="submit" onClick="prevStep();" value="prev"/>
  <input type="submit" onClick="nextStep();" value="next"/>
</div>

<div id="preso">loading presentation...</div>
<div id="footer">
  <span id="slideInfo"></span>
  <span id="debugInfo"></span>
  <span id="notesInfo"></span>
</div>

<div id="slides" class="offscreen" style="display:none;">
<div class="slide" data-transition="none"><div class="content" ref="1_intro/1">
<h1>A system for resource deadlock prevention</h1>

<h2>Louis Dionne, C++Now 2013</h2>
</div>
</div><div class="slide" data-transition="none"><div class="content" ref="1_intro/2">
<h1>Overview</h1>

<ul>
<li>The target: lock order inconsistencies</li>
<li>Existing solutions</li>
<li><code>d2</code>: a library-based approach

<ul>
<li>Design and usage</li>
<li>Algorithm</li>
<li>Roadmap</li>
</ul></li>
<li>Towards <code>dyno</code>: a DSEL for dynamic analysis</li>
</ul>
</div>
</div><div class="slide" data-transition="none"><div class="content subsection" ref="2_lock_order_inconsistencies/1">
<h1>Lock order inconsistencies</h1>
</div>
</div><div class="slide" data-transition="none"><div class="content" ref="2_lock_order_inconsistencies/2">
<h2>Example #1</h2>

<pre class="sh_cpp"><code>    mutex A, B;
    thread t1([&amp;] {
        scoped_lock a(A);
        scoped_lock b(B);
    });

    thread t2([&amp;] {
        scoped_lock b(B);
        scoped_lock a(A);
    });</code></pre>
</div>
</div><div class="slide" data-transition="none"><div class="content" ref="2_lock_order_inconsistencies/3">
<h2>Example #2</h2>

<pre class="sh_cpp"><code>    mutex A, B, C;
    thread t1([&amp;] {
        scoped_lock a(A);
        scoped_lock b(B);
    });

    thread t2([&amp;] {
        scoped_lock b(B);
        scoped_lock c(C);
    });

    thread t3([&amp;] {
        scoped_lock c(C);
        scoped_lock a(A);
    });</code></pre>
</div>
</div><div class="slide" data-transition="none"><div class="content" ref="2_lock_order_inconsistencies/4">
<h2>Same principle but harder to catch</h2>
</div>
</div><div class="slide" data-transition="none"><div class="content" ref="2_lock_order_inconsistencies/5">
<h1>Why are they so vicious?</h1>
</div>
</div><div class="slide" data-transition="none"><div class="content" ref="2_lock_order_inconsistencies/6">
<h2>Non deterministic</h2>
</div>
</div><div class="slide" data-transition="none"><div class="content" ref="2_lock_order_inconsistencies/7">
<p class="notes">Very few variations in thread scheduling usually happens for different
runs of the same code in the same conditions. For this reason, odds are that
rare deadlocks still make it to production and only happen under "extreme"
conditions.</p>

<h2>Often uncaught by unit tests</h2>
</div>
</div><div class="slide" data-transition="none"><div class="content" ref="2_lock_order_inconsistencies/8">
<h2>Difficult to reproduce</h2>
</div>
</div><div class="slide" data-transition="none"><div class="content" ref="2_lock_order_inconsistencies/9">
<h2>Finding them requires thinking about parallel executions, which is difficult</h2>
</div>
</div><div class="slide" data-transition="none"><div class="content" ref="2_lock_order_inconsistencies/10">
<h2>We would like to detect them automatically and before they happen</h2>
</div>
</div><div class="slide" data-transition="none"><div class="content subsection" ref="3_existing_solutions/1">
<h1>Existing solutions</h1>
</div>
</div><div class="slide" data-transition="none"><div class="content smbullets incremental" ref="3_existing_solutions/2">
<h2>Never hold more than one lock at once</h2>

<ul>
<li>Not realistic for non-trivial programs</li>
</ul>
</div>
</div><div class="slide" data-transition="none"><div class="content smbullets incremental" ref="3_existing_solutions/3">
<h2>Determine a hierarchy among locks and respect it</h2>

<ul>
<li>Error-prone</li>
<li>Not realistic for non-trivial programs</li>
</ul>
</div>
</div><div class="slide" data-transition="none"><div class="content smbullets incremental" ref="3_existing_solutions/4">
<h2>Disturb thread scheduling to provoke hidden deadlocks</h2>

<ul>
<li>Requires several runs of the program</li>
<li>Good idea that could be mixed with other approaches</li>
</ul>
</div>
</div><div class="slide" data-transition="none"><div class="content smbullets incremental" ref="3_existing_solutions/5">
<h2>Use an algorithm to break deadlocks when they happen</h2>

<ul>
<li>Overhead required to check for deadlock conditions</li>
<li>Policy for breaking deadlocks can't be pretty: kill the thread</li>
<li>Misses the point: deadlocks are a bug, not a runtime mishap</li>
</ul>
</div>
</div><div class="slide" data-transition="none"><div class="content smbullets incremental" ref="3_existing_solutions/6">
<h2>Intel&#xAE; Inspector XE</h2>

<ul>
<li>Detects deadlocks involving up to 4 threads only</li>
<li>Huge overhead</li>
<li>Proprietary and costly license</li>
<li>Exact capabilities for deadlock detection unknown</li>
</ul>
</div>
</div><div class="slide" data-transition="none"><div class="content smbullets incremental" ref="3_existing_solutions/7">
<h2>Valgrind (Helgrind)</h2>

<ul>
<li>Runs the program on a virtual processor, one thread at a time</li>
<li>Limited to POSIX pthreads threading primitives</li>
</ul>
</div>
</div><div class="slide" data-transition="none"><div class="content bullets incremental" ref="3_existing_solutions/8">
<h2>There are also several solutions for the JVM</h2>
</div>
</div><div class="slide" data-transition="none"><div class="content subsection" ref="4_d2/1_d2/1">
<h1><code>d2</code>: a library-based approach</h1>
</div>
</div><div class="slide" data-transition="none"><div class="content bullets incremental" ref="4_d2/1_d2/2">
<h1>Goals</h1>

<ul>
<li>Detect lock order inconsistencies between N threads</li>
<li>Support custom locks and threads easily</li>
<li>Low overhead when enabled, none when disabled</li>
<li>Very few false positives</li>
</ul>
</div>
</div><div class="slide" data-transition="none"><div class="content subsection" ref="4_d2/2_design_and_usage/1">
<h1>Design and usage</h1>
</div>
</div><div class="slide" data-transition="none"><div class="content bullets incremental" ref="4_d2/2_design_and_usage/2">
<h2><code>d2</code> needs to record 4 types of events</h2>

<ul>
<li>Lock acquire and release</li>
<li>Thread start and join</li>
</ul>
</div>
</div><div class="slide" data-transition="none"><div class="content smaller" ref="4_d2/2_design_and_usage/3">
<h2>High level API with concepts from Boost.Thread</h2>

<pre class="sh_cpp"><code>    boost::BasicLockable
    boost::Lockable
    boost::TimedLockable</code></pre>
</div>
</div><div class="slide" data-transition="none"><div class="content smaller" ref="4_d2/2_design_and_usage/4">
<h2>Simply wrap your class with the corresponding wrapper</h2>

<pre class="sh_cpp"><code>    struct untracked_mutex {
      void lock();
      void unlock();
    };

    typedef d2::basic_lockable&lt;untracked_mutex&gt; mutex;</code></pre>
</div>
</div><div class="slide" data-transition="none"><div class="content smaller" ref="4_d2/2_design_and_usage/5">
<h2>All wrappers have a recursive counterpart</h2>

<pre class="sh_cpp"><code>    d2::recursive_basic_lockable
    d2::recursive_lockable
    d2::recursive_timed_lockable</code></pre>
</div>
</div><div class="slide" data-transition="none"><div class="content smaller" ref="4_d2/2_design_and_usage/6">
<h2>You can also bypass the concept based API</h2>

<pre class="sh_cpp"><code>    class mutex
      : d2::trackable_sync_object&lt;d2::non_recursive&gt;
    {
    public:
      void some_method_to_lock() {
        // normal code
        this-&gt;notify_lock();
      }

      void some_method_to_unlock() {
        // normal code
        this-&gt;notify_unlock();
      }
    };</code></pre>
</div>
</div><div class="slide" data-transition="none"><div class="content smaller" ref="4_d2/2_design_and_usage/7">
<h2>Tracking standard conforming threads is easy</h2>

<pre class="sh_cpp"><code>    struct untracked_thread {
      // ...
    };

    typedef d2::standard_thread&lt;untracked_thread&gt; thread;</code></pre>
</div>
</div><div class="slide" data-transition="none"><div class="content smaller" ref="4_d2/2_design_and_usage/8">
<h2>Tracking non standard thread implementations is possible too</h2>

<pre class="sh_cpp"><code>    class thread : d2::trackable_thread&lt;thread&gt; {
    public:
      template &lt;typename F, typename ...Args&gt;
      void some_method_to_start(F&amp;&amp; f, Args&amp;&amp; ...args) {
        typedef d2::thread_function&lt;F&gt; F_;
        F_ f_ = this-&gt;get_thread_function(f);

        // normal code using F_ and f_
      }

      void some_method_to_join() {
        // normal code
        this-&gt;notify_join();
      }

      void some_method_to_detach() {
        // normal code
        this-&gt;notify_detach();
      }
    };</code></pre>
</div>
</div><div class="slide" data-transition="none"><div class="content smaller" ref="4_d2/2_design_and_usage/9">
<h2>Don't forget to modify these</h2>

<pre class="sh_cpp"><code>    thread(thread&amp;&amp; other);
    thread&amp; operator=(thread&amp;&amp; other);
    friend void swap(thread&amp; a, thread&amp; b);</code></pre>
</div>
</div><div class="slide" data-transition="none"><div class="content smaller" ref="4_d2/2_design_and_usage/10">
<h2>Low level C API (for eventual bindings)</h2>

<pre class="sh_c"><code>    d2_notify_acquire(thread, lock)
    d2_notify_release(thread, lock)
    d2_notify_recursive_acquire(thread, lock)
    d2_notify_recursive_release(thread, lock)
    d2_notify_start(parent, child)
    d2_notify_join(parent, child)</code></pre>
</div>
</div><div class="slide" data-transition="none"><div class="content" ref="4_d2/2_design_and_usage/11">
<h2>Events are generated and dispatched to the filesystem</h2>

<p><img src="./file/4_d2/example_repository.png" width="770" height="438" alt="Example repository"/>
</p>
</div>
</div><div id="mumbo_jumbo" class="slide" data-transition="none"><div class="content commandline" ref="4_d2/2_design_and_usage/12">
<h2>Mumbo jumbo on disk</h2>

<pre><code><code class="command">$ cat my_program/1    # thread 1</code>
<code class="result">22 serialization::archive 10 0 0 4 0 0 0 0 1 0 0 2 0 0 0 0 0 1 0 0 2 0 0 0 0 0 0 0 1 3 0 0 0 1 4 0 0 0 1 5 0 0 0 1 6 0 0 0 1 7 0 0 0 1 8 0 0 0 1 9 0 0 0 1 10 0 0 0 1 11 0 0 0 1 12 0 0 0 1 13 0 0 0 1 14 0 0 0 1 15 0 0 0 1 16 0 0 0 1 17 0 0 0 1 18 0 0 0 1 19 0 0 0 1 20 0 0 0 1 21 0 0 0 1 22 0 0 0 1 23 0 0 0 1 24 0 0 0 1 25 0 0 0 1 26 0 0 0 1 27 0 0 0 1 28 0 0 0 1 29 0 0 0 1 30 0 0 0 1 31 0 0 0 1 32 0 0 0 1 33 0 0 0 1 34 0 0 0 1 35 0 0 0 1 36 0 0 0 1 37 0 0 0 1 38 0 0 0 1 39 0 0 0 1 40 0 0 0 1 41 0 0 0 1 42 0 0 0 1 43 0 0 0 1 44 0 0 0 1 45 0 0 0 1 46 0 0 0 1 47 0 0 0 1 48 0 0 0 1 49 0 0 0 1 50 0 0 0 1 51 0 0 0 1 52 0 0 0 1 53 0 0 0 1 54 0 0 0 1 55 0 0 0 1 56 0 0 0 1 57 0 0 0 1 58 0 0 0 1 59 0 0 0 1 60 0 0 0 1 61 0 0 0 1 62 0 0 0 1 63 0 0 0 1 64 0 0 0 1 65 0 0 0 1 66 0 0 0 1 67 0 0 0 1 68 0 0 0 1 69 0 0 0 1 70 0 0 0 1 71 0 0 0 1 72 0 0 0 1 73 0 0 0 1 74 0 0 0 1 75 0 0 0 1 76 0 0 0 1 77 0 0 0 1 78 0 0 0 1 79 0 0 0 1 80 0 0 0 1 81 0 0 0 1 82 0 0 0 1 83 0 0 0 1 84 0 0 0 1 85 0 0 0 1 86 0 0 0 1 87 0 0 0 1 88 0 0 0 1 89 0 0 0 1 90 0 0 0 1 91 0 0 0 1 92 0 0 0 1 93 0 0 0 1 94 0 0 0 1 95 0 0 0 1 96 0 0 0 1 97 0 0 0 1 98 0 0 0 1 99 0 0 0 1 100 0 0 0 1 101 0 0 1 0 0 1 101 0 0 1 1 100 0 0 1 1 99 0 0 1 1 98 0 0 1 1 97 0 0 1 1 96 0 0 1 1 95 0 0 1 1 94 0 0 1 1 93 0 0 1 1 92 0 0 1 1 91 0 0 1 1 90 0 0 1 1 89 0 0 1 1 88 0 0 1 1 87 0 0 1 1 86 0 0 1 1 85 0 0 1 1 84 0 0 1 1 83 0 0 1 1 82 0 0 1 1 81 0 0 1 1 80 0 0 1 1 79 0 0 1 1 78 0 0 1 1 77 0 0 1 1 76 0 0 1 1 75 0 0 1 1 74 0 0 1 1 73 0 0 1 1 72 0 0 1 1 71 0 0 1 1 70 0 0 1 1 69 0 0 1 1 68 0 0 1 1 67 0 0 1 1 66 0 0 1 1 65 0 0 1 1 64 0 0 1 1 63 0 0 1 1 62 0 0 1 1 61 0 0 1 1 60 0 0 1 1 59 0 0 1 1 58 0 0 1 1 57 0 0 1 1 56 0 0 1 1 55 0 0 1 1 54 0 0 1 1 53 0 0 1 1 52 0 0 1 1 51 0 0 1 1 50 0 0 1 1 49 0 0 1 1 48 0 0 1 1 47 0 0 1 1 46 0 0 1 1 45 0 0 1 1 44 0 0 1 1 43 0 0 1 1 42 0 0 1 1 41 0 0 1 1 40 0 0 1 1 39 0 0 1 1 38 0 0 1 1 37 0 0 1 1 36 0 0 1 1 35 0 0 1 1 34 0 0 1 1 33 0 0 1 1 32 0 0 1 1 31 0 0 1 1 30 0 0 1 1 29 0 0 1 1 28 0 0 1 1 27 0 0 1 1 26 0 0 1 1 25 0 0 1 1 24 0 0 1 1 23 0 0 1 1 22 0 0 1 1 21 0 0 1 1 20 0 0 1 1 19 0 0 1 1 18 0 0 1 1 17 0 0 1 1 16 0 0 1 1 15 0 0 1 1 14 0 0 1 1 13 0 0 1 1 12 0 0 1 1 11 0 0 1 1 10 0 0 1 1 9 0 0 1 1 8 0 0 1 1 7 0 0 1 1 6 0 0 1 1 5 0 0 1 1 4 0 0 1 1 3 0 0 1 1 2 0 0
</code></code></pre>
</div>
</div><div id="d2_output_all" class="slide" data-transition="none"><div class="content commandline" ref="4_d2/2_design_and_usage/13">
<p class="notes">d2tool loads the events, constructs the graphs and performs the analysis.
Also mention that this output was cropped and edited a bit for clarity.</p>

<h2><code>d2tool</code> speaks that mumbo jumbo</h2>

<pre><code><code class="command">$ d2tool --analyze myprogram</code>
<code class="result">in thread #X started at [location]:
  holds object #Y acquired at [location]
  holds object #Z acquired at [location]
  ...
  tries to acquire object #W at [location]

in thread #XX started at [location]:
  holds object #YY acquired at [location]
  holds object #ZZ acquired at [location]
  ...
  tries to acquire object #WW at [location]
</code></code></pre>
</div>
</div><div id="d2_output" class="slide" data-transition="none"><div class="content commandline" ref="4_d2/2_design_and_usage/14">
<h2>where each [location] is a complete call stack:</h2>

<pre><code><code class="command">$ d2tool --analyze myprogram</code>
<code class="result">in thread #2 started at [no location information]:
holds object #1 acquired at
[...]/scenario_ABBA            main::$_1::operator()() const
[...]/scenario_ABBA            boost::detail::function::void_function_obj_invoker0&lt;main::$_1, void&gt;::invoke(boost::detail::function::function_buffer&amp;)
[...]/scenario_ABBA            boost::function0&lt;void&gt;::operator()() const
[...]/scenario_ABBA            d2mock::thread::impl::impl(boost::function&lt;void ()&gt; const&amp;)::'lambda'()::operator()() const
[...]/scenario_ABBA            d2::thread_function&lt;d2mock::thread::impl::impl(boost::function&lt;void ()&gt; const&amp;)::'lambda'()&gt;::result&lt;d2::thread_function&lt;d2mock::thread::impl::impl(boost::function&lt;void ()&gt; const&amp;)::'lambda'()&gt; ()&gt;::type d2::thread_function&lt;d2mock::thread::impl::impl(boost::function&lt;void ()&gt; const&amp;)::'lambda'()&gt;::operator()&lt;&gt;()
[...]/scenario_ABBA            boost::detail::thread_data&lt;d2::thread_function&lt;d2mock::thread::impl::impl(boost::function&lt;void ()&gt; const&amp;)::'lambda'()&gt; &gt;::run()
[...]/libboost_thread-mt.dylib thread_proxy
[...]/libsystem_c.dylib        _pthread_start
[...]/libsystem_c.dylib        thread_start
...
</code></code></pre>
</div>
</div><div class="slide" data-transition="none"><div class="content bullets incremental" ref="4_d2/2_design_and_usage/15">
<h2>Current limitations:</h2>

<ul>
<li>Output is not as nicely formatted</li>
<li>Thread starts have no location information</li>
</ul>
</div>
</div><div class="slide" data-transition="none"><div class="content subsection" ref="4_d2/3_algorithm/1_algorithm/1">
<h1>The algorithm</h1>
</div>
</div><div class="slide" data-transition="none"><div class="content" ref="4_d2/3_algorithm/1_algorithm/2">
<h1>Disclaimer:</h1>

<p>I am <strong>not</strong> the author of the algorithm. It is presented in:</p>

<p>"Detection of deadlock potentials in multithreaded programs",
IBM Journal of Research and Development, vol.54, no.5, pp.3:1,3:15,
Sept.-Oct. 2010</p>
</div>
</div><div class="slide" data-transition="none"><div class="content" ref="4_d2/3_algorithm/1_algorithm/3">
<h2>A note for the rest of the presentation:</h2>

<p>For brevity, unlocking mutexes and joining threads will often be omitted.
When omitted, assume the mutexes are unlocked in reverse order of locking
and threads are joined in reverse order of starting.</p>
</div>
</div><div class="slide" data-transition="none"><div class="content" ref="4_d2/3_algorithm/1_algorithm/4">
<h2>So these are the same:</h2>

<pre class="sh_cpp"><code>    mutex A, B;
    A.lock();
        B.lock();
        B.unlock();
    A.unlock();</code></pre>

<h2>and</h2>

<pre class="sh_cpp"><code>    mutex A, B;
    A.lock();
        B.lock();</code></pre>
</div>
</div><div class="slide" data-transition="none"><div class="content" ref="4_d2/3_algorithm/1_algorithm/5">
<h2>And so are these:</h2>

<pre class="sh_cpp"><code>    thread t1([] {});
        thread t2([] {});
        t2.join();
    t1.join();</code></pre>

<h2>and</h2>

<pre class="sh_cpp"><code>    thread t1([] {});
        thread t2([] {});</code></pre>
</div>
</div><div class="slide" data-transition="none"><div class="content smbullets incremental" ref="4_d2/3_algorithm/1_algorithm/6">
<p class="notes">Specify that we'll be adding annotation on the graph to encode more
information like segmentation and gatelocks. Precise that we'll start with
the most basic graph and add annotations as we go to improve the algorithm.</p>

<h2>The basic idea is to build a graph where:</h2>

<ul>
<li>Vertices represent synchronization objects</li>
<li>An edge from <code>u</code> to <code>v</code> means that a thread acquired <code>v</code> while holding <code>u</code></li>
<li>A cycle in the graph represents a potential deadlock</li>
</ul>
</div>
</div><div class="slide" data-transition="none"><div class="content graph_example" ref="4_d2/3_algorithm/2_basic_lock_graph/1">
<p class="notes">Two nodes are created because we created two locks, but no edges are
created because we did not lock anything.</p>

<h2>Example #1</h2>

<pre class="sh_cpp"><code>    mutex A, B;</code></pre>

<p><img src="https://chart.googleapis.com/chart?cht=gv&amp;chl=digraph%20%7B%0A%20%20%20%20graph%20%5Bbgcolor%20=%20transparent%5D;%0A%20%20%20%20A;%20B;%0A%7D" alt=""/>
</p>
</div>
</div><div class="slide" data-transition="none"><div class="content graph_example" ref="4_d2/3_algorithm/2_basic_lock_graph/2">
<h2>Example #1</h2>

<p>No edge is created; the main thread does not hold anything when it acquires <code>A</code>.</p>

<pre class="sh_cpp"><code>    mutex A, B;
    A.lock();</code></pre>

<p><img src="https://chart.googleapis.com/chart?cht=gv&amp;chl=digraph%20%7B%0A%20%20%20%20graph%20%5Bbgcolor%20=%20transparent%5D;%0A%20%20%20%20A;%20B;%0A%7D" alt=""/>
</p>
</div>
</div><div class="slide" data-transition="none"><div class="content graph_example" ref="4_d2/3_algorithm/2_basic_lock_graph/3">
<h2>Example #1</h2>

<p>The main thread holds <code>A</code> when it acquires <code>B</code>; we add an edge from <code>A</code> to <code>B</code>.</p>

<pre class="sh_cpp"><code>    mutex A, B;
    A.lock();
        B.lock();</code></pre>

<p><img src="https://chart.googleapis.com/chart?cht=gv&amp;chl=digraph%20%7B%0A%20%20%20%20graph%20%5Bbgcolor%20=%20transparent%5D;%0A%20%20%20%20A-%3EB;%0A%7D" alt=""/>
</p>
</div>
</div><div class="slide" data-transition="none"><div class="content graph_example" ref="4_d2/3_algorithm/2_basic_lock_graph/4">
<h2>Example #1</h2>

<p>The graph is not modified on releases.</p>

<pre class="sh_cpp"><code>    mutex A, B;
    A.lock();
        B.lock();
        B.unlock();
    A.unlock();</code></pre>

<p><img src="https://chart.googleapis.com/chart?cht=gv&amp;chl=digraph%20%7B%0A%20%20%20%20graph%20%5Bbgcolor%20=%20transparent%5D;%0A%20%20%20%20A-%3EB;%0A%7D" alt=""/>
</p>
</div>
</div><div class="slide" data-transition="none"><div class="content graph_example" ref="4_d2/3_algorithm/2_basic_lock_graph/5">
<p class="notes">Since there is already an edge from A to B in the graph, we don't add
it redundantly if a thread locks B again while holding A.</p>

<h2>Example #1</h2>

<p>We don't add redundant edges.</p>

<pre class="sh_cpp"><code>    mutex A, B;
    A.lock();
        B.lock();
        B.unlock();
    A.unlock();

    A.lock();
    B.lock();</code></pre>

<p><img src="https://chart.googleapis.com/chart?cht=gv&amp;chl=digraph%20%7B%0A%20%20%20%20graph%20%5Bbgcolor%20=%20transparent%5D;%0A%20%20%20%20A%20-%3E%20B;%0A%7D" alt=""/>
</p>
</div>
</div><div class="slide" data-transition="none"><div class="content graph_example" ref="4_d2/3_algorithm/2_basic_lock_graph/6">
<h2>Example #2</h2>

<pre class="sh_cpp"><code>    mutex A, B, C, D;
    A.lock();
    B.lock();</code></pre>

<p><img src="https://chart.googleapis.com/chart?cht=gv&amp;chl=digraph%20%7B%0A%20%20%20%20graph%20%5Bbgcolor%20=%20transparent%5D;%0A%20%20%20%20A;%20B;%20C;%20D;%0A%20%20%20%20A-%3EB;%0A%7D" alt=""/>
</p>
</div>
</div><div class="slide" data-transition="none"><div class="content graph_example" ref="4_d2/3_algorithm/2_basic_lock_graph/7">
<h2>Example #2</h2>

<p>We're really computing the transitive closure of the "is held by a thread
when acquiring X" relation.</p>

<pre class="sh_cpp"><code>    mutex A, B, C, D;
    A.lock();
    B.lock();
    C.lock();</code></pre>

<p><img src="https://chart.googleapis.com/chart?cht=gv&amp;chl=digraph%20%7B%0A%20%20%20%20graph%20%5Bbgcolor%20=%20transparent%5D;%0A%20%20%20%20A;%20B;%20C;%20D;%0A%20%20%20%20A-%3EB;%0A%20%20%20%20A-%3EC;%0A%20%20%20%20B-%3EC;%0A%7D" alt=""/>
</p>
</div>
</div><div class="slide" data-transition="none"><div class="content graph_example" ref="4_d2/3_algorithm/2_basic_lock_graph/8">
<h2>Example #2</h2>

<p>We're really computing the transitive closure of the "is held by a thread
when acquiring X" relation.</p>

<pre class="sh_cpp"><code>    mutex A, B, C, D;
    A.lock();
    B.lock();
    C.lock();
    D.lock();</code></pre>

<p><img src="https://chart.googleapis.com/chart?cht=gv&amp;chl=digraph%20%7B%0A%20%20%20%20graph%20%5Bbgcolor%20=%20transparent%5D;%0A%20%20%20%20A-%3EB;%0A%20%20%20%20A-%3EC;%0A%20%20%20%20B-%3EC;%0A%20%20%20%20A-%3ED;%0A%20%20%20%20B-%3ED;%0A%20%20%20%20C-%3ED;%0A%7D" alt=""/>
</p>
</div>
</div><div class="slide" data-transition="none"><div class="content graph_example" ref="4_d2/3_algorithm/2_basic_lock_graph/9">
<h2>Example #3: A potential deadlock</h2>

<pre class="sh_cpp"><code>mutex A, B;
thread t1([&amp;] {
    A.lock();
    B.lock();
});

// ...</code></pre>

<p><img src="https://chart.googleapis.com/chart?cht=gv&amp;chl=digraph%20%7B%0A%20%20%20%20graph%20%5Bbgcolor%20=%20transparent%5D;%0A%20%20%20%20A-%3EB;%0A%7D" alt=""/>
</p>
</div>
</div><div class="slide" data-transition="none"><div class="content graph_example" ref="4_d2/3_algorithm/2_basic_lock_graph/10">
<p class="notes">Clearly, there is a cycle in the graph iff two locks were acquired in
some order and then acquired in a different order.</p>

<h2>Example #3: A potential deadlock</h2>

<pre class="sh_cpp"><code>mutex A, B;
thread t1([&amp;] {
    A.lock();
    B.lock();
});

thread t2([&amp;] {
    B.lock();
    A.lock();
});</code></pre>

<p><img src="https://chart.googleapis.com/chart?cht=gv&amp;chl=digraph%20%7B%0A%20%20%20%20graph%20%5Bbgcolor%20=%20transparent%5D;%0A%20%20%20%20A-%3EB;%0A%20%20%20%20B-%3EA;%0A%7D" alt=""/>
</p>
</div>
</div><div class="slide" data-transition="none"><div class="content graph_example" ref="4_d2/3_algorithm/2_basic_lock_graph/11">
<h2>Example # 4: Another potential deadlock</h2>

<pre class="sh_cpp"><code>    mutex A, B, C, D;
    thread t1([&amp;]{
        A.lock();
        B.lock();
        C.lock();
        D.lock();
    });

    // ...</code></pre>

<p><img src="https://chart.googleapis.com/chart?cht=gv&amp;chl=digraph%20%7B%0A%20%20%20%20graph%20%5Bbgcolor%20=%20transparent%5D;%0A%20%20%20%20A-%3EB;%0A%20%20%20%20A-%3EC;%0A%20%20%20%20B-%3EC;%0A%20%20%20%20A-%3ED;%0A%20%20%20%20B-%3ED;%0A%20%20%20%20C-%3ED;%0A%7D" alt=""/>
</p>
</div>
</div><div class="slide" data-transition="none"><div class="content graph_example" ref="4_d2/3_algorithm/2_basic_lock_graph/12">
<h2>Example #4: Another potential deadlock</h2>

<pre class="sh_cpp"><code>    mutex A, B, C, D;
    thread t1([&amp;]{
        A.lock();
        B.lock();
        C.lock();
        D.lock();
    });

    thread t2([&amp;]{
        D.lock();
        B.lock();
    });</code></pre>

<p><img src="https://chart.googleapis.com/chart?cht=gv&amp;chl=digraph%20%7B%0A%20%20%20%20graph%20%5Bbgcolor%20=%20transparent%5D;%0A%20%20%20%20A-%3EB;%0A%20%20%20%20A-%3EC;%0A%20%20%20%20B-%3EC;%0A%20%20%20%20A-%3ED;%0A%20%20%20%20B-%3ED;%0A%20%20%20%20C-%3ED;%0A%20%20%20%20D-%3EB;%0A%7D" alt=""/>
</p>
</div>
</div><div class="slide" data-transition="none"><div class="content source_code_270P graph_example" ref="4_d2/3_algorithm/2_basic_lock_graph/13">
<h2>Example #5: It works for an arbitrary number of threads</h2>

<pre class="sh_cpp"><code>    mutex A, B, C;
    thread t1([&amp;] {
        A.lock();
        B.lock();
    });

    thread t2([&amp;] {
        B.lock();
        C.lock();
    });

    thread t3([&amp;] {
        C.lock();
        A.lock();
    });</code></pre>

<p><img src="https://chart.googleapis.com/chart?cht=gv&amp;chl=digraph%20%7B%0A%20%20%20%20graph%20%5Bbgcolor%20=%20transparent%5D;%0A%20%20%20%20A-%3EB;%0A%20%20%20%20B-%3EC;%0A%20%20%20%20C-%3EA;%0A%7D" alt=""/>
</p>
</div>
</div><div class="slide" data-transition="none"><div class="content graph_example" ref="4_d2/3_algorithm/2_basic_lock_graph/14">
<p class="notes">Since there is only one thread involved, a deadlock can't possibly
happen. Actually, the generalization is that all the code in this thread is
implicitly serialized (because it is run in a single thread of execution).
Therefore, there exists an implicit happens-before relationship between the
statements. Note that a deadlock could still happen if a non-recursive lock
was locked recursively by a thread. However, whether such a deadlock happens
depends on whether the code path leading to it is taken. In other words, it
is deterministic as far as thread scheduling is concerned. If the code path
is taken, the deadlock is 100% to happen. Otherwise, the deadlock won't
happen and we won't detect anything anyway since the code path was <em>not</em>
taken (and we're doing dynamic analysis).</p>

<h2>However, the algorithm can report false positives. Consider:</h2>

<pre class="sh_cpp"><code>    mutex A, B;
    thread t1([&amp;] {
        A.lock();
            B.lock();
            B.unlock();
        A.unlock();

        B.lock();
            A.lock();
            A.unlock();
        B.unlock();
    });</code></pre>

<p><img src="https://chart.googleapis.com/chart?cht=gv&amp;chl=digraph%20%7B%0A%20%20%20%20graph%20%5Bbgcolor%20=%20transparent%5D;%0A%20%20%20%20A-%3EB;%0A%20%20%20%20B-%3EA;%0A%7D" alt=""/>
</p>
</div>
</div><div class="slide" data-transition="none"><div class="content" ref="4_d2/3_algorithm/3_lock_graph_with_threads/1">
<p class="notes">If a cycle contains two edges labelled with the same thread, it is
ignored because the represented deadlock would require code in the same
thread to run concurrently, which is impossible. This is effectively a
special case of the happens-before relationship.</p>

<p>Let's augment the lock graph by labelling each edge with the thread that
caused that edge to be added.</p>

<p>We will ignore cycles containing two edges labelled with the same thread.</p>
</div>
</div><div class="slide" data-transition="none"><div class="content graph_example" ref="4_d2/3_algorithm/3_lock_graph_with_threads/2">
<h2>Example #6</h2>

<p>No labels, no edges, like the basic graph.</p>

<pre class="sh_cpp"><code>    mutex A, B;

    // ...</code></pre>

<p><img src="https://chart.googleapis.com/chart?cht=gv&amp;chl=digraph%20%7B%0A%20%20%20%20graph%20%5Bbgcolor%20=%20transparent%5D;%0A%20%20%20%20A;%20B;%0A%7D" alt=""/>
</p>
</div>
</div><div class="slide" data-transition="none"><div class="content graph_example" ref="4_d2/3_algorithm/3_lock_graph_with_threads/3">
<h2>Example #6</h2>

<p>When an edge is added, we label it with the thread that caused its addition.</p>

<pre class="sh_cpp"><code>    mutex A, B;
    thread t1([&amp;] {
        A.lock();
        B.lock();
    });

    // ...</code></pre>

<p><img src="https://chart.googleapis.com/chart?cht=gv&amp;chl=digraph%20%7B%0A%20%20%20%20graph%20%5Bbgcolor%20=%20transparent,%20rankdir%20=%20LR%5D;%0A%20%20%20%20A-%3EB%20%5Blabel=t1%5D;%0A%7D" alt=""/>
</p>
</div>
</div><div class="slide" data-transition="none"><div class="content graph_example" ref="4_d2/3_algorithm/3_lock_graph_with_threads/4">
<h2>Example #6</h2>

<p>We add a parallel edge if the label on it is different from that of existing
edges.</p>

<pre class="sh_cpp"><code>    mutex A, B;
    thread t1([&amp;] {
        A.lock();
        B.lock();
    });

    thread t2([&amp;] {
        A.lock();
        B.lock();
    });</code></pre>

<p><img src="https://chart.googleapis.com/chart?cht=gv&amp;chl=digraph%20%7B%0A%20%20%20%20graph%20%5Bbgcolor%20=%20transparent,%20rankdir%20=%20LR%5D;%0A%20%20%20%20A-%3EB%20%5Blabel=t1%5D;%0A%20%20%20%20A-%3EB%20%5Blabel=t2%5D;%0A%7D" alt=""/>
</p>
</div>
</div><div class="slide" data-transition="none"><div class="content graph_example" ref="4_d2/3_algorithm/3_lock_graph_with_threads/5">
<p>Consider the previous graph with a false positive. We now ignore the single
threaded cycle:</p>

<pre class="sh_cpp"><code>    mutex A, B;
    thread t1([&amp;] {
        A.lock();
            B.lock();
            B.unlock();
        A.unlock();

        B.lock();
        A.lock();
    });</code></pre>

<p><img src="https://chart.googleapis.com/chart?cht=gv&amp;chl=digraph%20%7B%0A%20%20%20%20graph%20%5Bbgcolor%20=%20transparent,%20rankdir%20=%20LR%5D;%0A%20%20%20%20A-%3EB%20%5Blabel=t1%5D;%0A%20%20%20%20B-%3EA%20%5Blabel=t1%5D;%0A%7D" alt=""/>
</p>
</div>
</div><div class="slide" data-transition="none"><div class="content graph_example source_code_230P" ref="4_d2/3_algorithm/3_lock_graph_with_threads/6">
<p class="notes">The A-&gt;B-&gt;C cycle with three different threads is a real potential
deadlock. The other A-&gt;B-&gt;C with t1, t2, t2 is a false positive and is ignore
because t2 appears twice in the cycle.</p>

<p>And cycles still represent potential deadlocks.</p>

<pre class="sh_cpp"><code>    mutex A, B, C;
    thread t1([&amp;] {
        A.lock();
        B.lock();
    });

    thread t2([&amp;] {
        B.lock();
            C.lock();
            C.unlock();
        B.unlock();

        C.lock();
        A.lock();
    });

    thread t3([&amp;] {
        C.lock();
        A.lock();
    });</code></pre>

<p><img src="https://chart.googleapis.com/chart?cht=gv&amp;chl=digraph%20%7B%0A%20%20%20%20graph%20%5Bbgcolor%20=%20transparent,%20rankdir%20=%20LR%5D;%0A%20%20%20%20A-%3EB%20%5Blabel=t1%5D;%0A%20%20%20%20B-%3EC%20%5Blabel=t2%5D;%0A%20%20%20%20C-%3EA%20%5Blabel=t2%5D;%0A%20%20%20%20C-%3EA%20%5Blabel=t3%5D;%0A%7D" alt=""/>
</p>
</div>
</div><div class="slide" data-transition="none"><div class="content graph_example" ref="4_d2/3_algorithm/3_lock_graph_with_threads/7">
<p class="notes">The deadlock may never happen because G has to be held by both threads
in order to enter the dangerous section of the code.</p>

<p>However, consider this situation. Both threads must be holding <code>G</code>, which
is impossible:</p>

<pre class="sh_cpp"><code>        mutex A, B, G;
        thread t1([&amp;] {
            G.lock();
            A.lock();
            B.lock();
        });

        thread t2([&amp;] {
            G.lock();
            B.lock();
            A.lock();
        });</code></pre>

<p><img src="https://chart.googleapis.com/chart?cht=gv&amp;chl=digraph%20%7B%0A%20%20%20%20graph%20%5Bbgcolor%20=%20transparent%5D;%0A%20%20%20%20%7Brank%20=%20same;%20A;%20B;%7D%0A%20%20%20%20G-%3EA%20%5Blabel=t1%5D;%0A%20%20%20%20G-%3EB%20%5Blabel=t1%5D;%0A%20%20%20%20A-%3EB%20%5Blabel=t1%5D;%0A%20%20%20%20G-%3EB%20%5Blabel=t2%5D;%0A%20%20%20%20G-%3EA%20%5Blabel=t2%5D;%0A%20%20%20%20B-%3EA%20%5Blabel=t2%5D;%0A%7D" alt=""/>
</p>
</div>
</div><div class="slide" data-transition="none"><div class="content" ref="4_d2/3_algorithm/3_lock_graph_with_threads/8">
<h2>We say that <code>G</code> is a 'gatelock' protecting that cycle</h2>
</div>
</div><div class="slide" data-transition="none"><div class="content" ref="4_d2/3_algorithm/4_lock_graph_with_gatelocks/1">
<p>This time, we will augment the edge labels to record the set of locks held by
the thread causing an edge to be added to the lock graph.</p>

<p>A cycle is not valid if the gatelock sets of any two edges in the cycle
intersect, i.e. if they share one or more gatelocks.</p>
</div>
</div><div class="slide" data-transition="none"><div class="content graph_example" ref="4_d2/3_algorithm/4_lock_graph_with_gatelocks/2">
<h2>Example #7</h2>

<pre class="sh_cpp"><code>    mutex A, B, C, D;

    // ...</code></pre>

<p><img src="https://chart.googleapis.com/chart?cht=gv&amp;chl=digraph%20%7B%0A%20%20%20%20graph%20%5Bbgcolor%20=%20transparent,%20rankdir%20=%20LR%5D;%0A%20%20%20%20A;%20B;%20C;%20D;%0A%7D" alt=""/>
</p>
</div>
</div><div class="slide" data-transition="none"><div class="content graph_example" ref="4_d2/3_algorithm/4_lock_graph_with_gatelocks/3">
<h2>Example #7</h2>

<p><code>t1</code> acquires <code>A</code> while holding nothing</p>

<pre class="sh_cpp"><code>    mutex A, B, C, D;
    thread t1([&amp;] {
        A.lock();
        // ...
    });

    // ...</code></pre>

<p><img src="https://chart.googleapis.com/chart?cht=gv&amp;chl=digraph%20%7B%0A%20%20%20%20graph%20%5Bbgcolor%20=%20transparent,%20rankdir%20=%20LR%5D;%0A%20%20%20%20A;%20B;%20C;%20D;%0A%7D" alt=""/>
</p>
</div>
</div><div class="slide" data-transition="none"><div class="content graph_example" ref="4_d2/3_algorithm/4_lock_graph_with_gatelocks/4">
<p class="notes">It is NOT redundant to put <code>A</code> in the set of gatelocks, as can be seen
in the next slide.</p>

<h2>Example #7</h2>

<p><code>t1</code> acquires <code>B</code> while holding <code>A</code>; <code>A</code> is put in the gatelocks for that edge</p>

<pre class="sh_cpp"><code>    mutex A, B, C, D;
    thread t1([&amp;] {
        A.lock();
        B.lock();
        // ...
    });

    // ...</code></pre>

<p><img src="https://chart.googleapis.com/chart?cht=gv&amp;chl=digraph%20%7B%0A%20%20%20%20graph%20%5Bbgcolor%20=%20transparent,%20rankdir%20=%20LR%5D;%0A%20%20%20%20A;%20B;%20C;%20D;%0A%20%20%20%20A-%3EB%20%5Blabel=%22t1%20:%20%7BA%7D%22%5D;%0A%7D" alt=""/>
</p>
</div>
</div><div class="slide" data-transition="none"><div class="content graph_example" ref="4_d2/3_algorithm/4_lock_graph_with_gatelocks/5">
<p class="notes">Here, we can see that putting <code>B</code> in the set of gatelocks when
acquiring <code>C</code> is not redundant, because the edge from <code>A</code> to <code>C</code> needs it.</p>

<h2>Example #7</h2>

<p><code>t1</code> acquires <code>C</code> while holding <code>A</code> and <code>B</code>; all the edges that are added to
the graph are marked with these gatelocks</p>

<pre class="sh_cpp"><code>    mutex A, B, C, D;
    thread t1([&amp;] {
        A.lock();
        B.lock();
        C.lock();
    });

    // ...</code></pre>

<p><img src="https://chart.googleapis.com/chart?cht=gv&amp;chl=digraph%20%7B%0A%20%20%20%20graph%20%5Bbgcolor%20=%20transparent,%20splines%20=%20curved%5D;%0A%20%20%20%20A;%20B;%20C;%20D;%0A%20%20%20%20A-%3EB%20%5Blabel=%22t1%20:%20%7BA%7D%22%5D;%0A%20%20%20%20A-%3EC%20%5Blabel=%22t1%20:%20%7BA,%20B%7D%22%5D;%0A%20%20%20%20B-%3EC%20%5Blabel=%22t1%20:%20%7BA,%20B%7D%22%5D;%0A%7D" alt=""/>
</p>
</div>
</div><div class="slide" data-transition="none"><div class="content graph_example" ref="4_d2/3_algorithm/4_lock_graph_with_gatelocks/6">
<h2>Example #7</h2>

<p><code>t2</code> acquires <code>D</code> while holding nothing</p>

<pre class="sh_cpp"><code>    mutex A, B, C, D;
    thread t1([&amp;] {
        A.lock();
        B.lock();
        C.lock();
    });

    thread t2([&amp;] {
        D.lock();
        // ...
    });</code></pre>

<p><img src="https://chart.googleapis.com/chart?cht=gv&amp;chl=digraph%20%7B%0A%20%20%20%20graph%20%5Bbgcolor%20=%20transparent,%20splines%20=%20curved%5D;%0A%20%20%20%20A-%3EB%20%5Blabel=%22t1%20:%20%7BA%7D%22%5D;%0A%20%20%20%20A-%3EC%20%5Blabel=%22t1%20:%20%7BA,%20B%7D%22%5D;%0A%20%20%20%20B-%3EC%20%5Blabel=%22t1%20:%20%7BA,%20B%7D%22%5D;%0A%7D" alt=""/>
</p>
</div>
</div><div class="slide" data-transition="none"><div class="content graph_example" ref="4_d2/3_algorithm/4_lock_graph_with_gatelocks/7">
<h2>Example #7</h2>

<p><code>t2</code> acquires <code>A</code> while holding <code>D</code></p>

<pre class="sh_cpp"><code>    mutex A, B, C, D;
    thread t1([&amp;] {
        A.lock();
        B.lock();
        C.lock();
    });

    thread t2([&amp;] {
        D.lock();
        A.lock();
        // ...
    });</code></pre>

<p><img src="https://chart.googleapis.com/chart?cht=gv&amp;chl=digraph%20%7B%0A%20%20%20%20graph%20%5Bbgcolor%20=%20transparent,%20splines%20=%20curved%5D;%0A%20%20%20%20A-%3EB%20%5Blabel=%22t1%20:%20%7BA%7D%22%5D;%0A%20%20%20%20A-%3EC%20%5Blabel=%22t1%20:%20%7BA,%20B%7D%22%5D;%0A%20%20%20%20B-%3EC%20%5Blabel=%22t1%20:%20%7BA,%20B%7D%22%5D;%0A%20%20%20%20D-%3EA%20%5Blabel=%22t2%20:%20%7BD%7D%22%5D;%0A%7D" alt=""/>
</p>
</div>
</div><div class="slide" data-transition="none"><div class="content graph_example" ref="4_d2/3_algorithm/4_lock_graph_with_gatelocks/8">
<h2>Example #7</h2>

<p><code>t2</code> acquires <code>B</code> while holding <code>D</code> and <code>A</code></p>

<pre class="sh_cpp"><code>    mutex A, B, C, D;
    thread t1([&amp;] {
        A.lock();
        B.lock();
        C.lock();
    });

    thread t2([&amp;] {
        D.lock();
        A.lock();
        B.lock();
    });</code></pre>

<p><img src="https://chart.googleapis.com/chart?cht=gv&amp;chl=digraph%20%7B%0A%20%20%20%20graph%20%5Bbgcolor%20=%20transparent,%20splines%20=%20curved%5D;%0A%20%20%20%20A-%3EB%20%5Blabel=%22t1%20:%20%7BA%7D%22%5D;%0A%20%20%20%20A-%3EC%20%5Blabel=%22t1%20:%20%7BA,%20B%7D%22%5D;%0A%20%20%20%20B-%3EC%20%5Blabel=%22t1%20:%20%7BA,%20B%7D%22%5D;%0A%20%20%20%20D-%3EA%20%5Blabel=%22t2%20:%20%7BD%7D%22%5D;%0A%20%20%20%20D-%3EB%20%5Blabel=%22t2%20:%20%7BD,%20A%7D%22%5D;%0A%20%20%20%20A-%3EB%20%5Blabel=%22t2%20:%20%7BD,%20A%7D%22%5D;%0A%7D" alt=""/>
</p>
</div>
</div><div class="slide" data-transition="none"><div class="content" ref="4_d2/3_algorithm/4_lock_graph_with_gatelocks/9">
<h2>Now consider the previous graph with a false positive:</h2>

<p><img src="https://chart.googleapis.com/chart?cht=gv&amp;chl=digraph%20%7B%0A%20%20%20%20graph%20%5Bbgcolor%20=%20transparent,%20rankdir%20=%20LR,%20splines%20=%20curved%5D;%0A%20%20%20%20G-%3EA%20%5Blabel=%22t1%20:%20%7BG%7D%22%5D;%0A%20%20%20%20G-%3EB%20%5Blabel=%22t1%20:%20%7BG,%20A%7D%22%5D;%0A%20%20%20%20A-%3EB%20%5Blabel=%22t1%20:%20%7BG,%20A%7D%22%5D;%0A%20%20%20%20G-%3EB%20%5Blabel=%22t2%20:%20%7BG%7D%22%5D;%0A%20%20%20%20G-%3EA%20%5Blabel=%22t2%20:%20%7BG,%20B%7D%22%5D;%0A%20%20%20%20B-%3EA%20%5Blabel=%22t2%20:%20%7BG,%20B%7D%22%5D;%0A%7D" alt=""/>

<p>As expected, the false positive is inhibited by the intersecting sets of
gatelocks.</p>
</p>
</div>
</div><div class="slide" data-transition="none"><div class="content graph_example" ref="4_d2/3_algorithm/4_lock_graph_with_gatelocks/10">
<h2>However, consider this situation, where <code>t1</code> and <code>t2</code> will never run in parallel:</h2>

<pre class="sh_cpp"><code>    mutex A, B;
    thread t1([&amp;] {
        A.lock();
        B.lock();
    });
    t1.join();

    thread t2([&amp;] {
        B.lock();
        A.lock();
    });
    t2.join();</code></pre>

<p><img src="https://chart.googleapis.com/chart?cht=gv&amp;chl=digraph%20%7B%0A%20%20%20%20graph%20%5Bbgcolor%20=%20transparent,%20rankdir%20=%20LR%5D;%0A%20%20%20%20A-%3EB%20%5Blabel=%22t1%20:%20%7BA%7D%22%5D;%0A%20%20%20%20B-%3EA%20%5Blabel=%22t2%20:%20%7BB%7D%22%5D;%0A%7D" alt=""/>
</p>
</div>
</div><div class="slide" data-transition="none"><div class="content" ref="4_d2/3_algorithm/4_lock_graph_with_gatelocks/11">
<h2>We say that <code>t1</code> 'happens-before' <code>t2</code>.</h2>
</div>
</div><div class="slide" data-transition="none"><div class="content" ref="4_d2/3_algorithm/5_segmentation_graph/1">
<h1>The happens-before relation</h1>
</div>
</div><div class="slide" data-transition="none"><div class="content" ref="4_d2/3_algorithm/5_segmentation_graph/2">
<p>We can implement this relation by associating an identifier to segments of the
code that are separated by the start or join of a thread.</p>
</div>
</div><div class="slide" data-transition="none"><div class="content" ref="4_d2/3_algorithm/5_segmentation_graph/3">
<p>When a thread starts another thread, both the parent and the child threads are
assigned new segment identifiers.</p>
</div>
</div><div class="slide" data-transition="none"><div class="content" ref="4_d2/3_algorithm/5_segmentation_graph/4">
<p>When a thread joins another thread, the parent thread continues executing with
a new segment identifier.</p>
</div>
</div><div class="slide" data-transition="none"><div class="content" ref="4_d2/3_algorithm/5_segmentation_graph/5">
<p>By drawing directed edges between the segments, we end up with a graph where
node <code>v</code> is reachable from node <code>u</code> iff <code>u</code> happens before <code>v</code>.</p>
</div>
</div><div class="slide" data-transition="none"><div class="content" ref="4_d2/3_algorithm/5_segmentation_graph/6">
<p>If two acquires do not happen before the other, then they must surely happen
in parallel.</p>
</div>
</div><div class="slide" data-transition="none"><div class="content graph_example segmentation_graph" ref="4_d2/3_algorithm/5_segmentation_graph/7">
<h2>Example #8</h2>

<p><code>main</code> starts in segment 0</p>

<pre class="sh_cpp"><code>    // ...</code></pre>

<p><img src="https://chart.googleapis.com/chart?cht=gv&amp;chl=digraph%20%7B%0A%20%20%20%20graph%20%5Bbgcolor%20=%20transparent,%20splines%20=%20ortho%5D;%0A%20%20%20%20subgraph%20cluster_main%20%7B%0A%20%20%20%20%20%20%20%20label%20=%20%22main%22;%0A%20%20%20%20%20%20%20%20main0%20%5Blabel%20=%20s0%5D;%0A%20%20%20%20%7D%0A%7D" alt=""/>
</p>
</div>
</div><div class="slide" data-transition="none"><div class="content graph_example segmentation_graph" ref="4_d2/3_algorithm/5_segmentation_graph/8">
<h2>Example #8</h2>

<p><code>main</code> starts <code>t1</code>; <code>main</code> and <code>t1</code> get new segments</p>

<pre class="sh_cpp"><code>    thread t1([] {});
    // ...</code></pre>

<p><img src="https://chart.googleapis.com/chart?cht=gv&amp;chl=digraph%20%7B%0A%20%20%20%20graph%20%5Bbgcolor%20=%20transparent,%20splines%20=%20ortho%5D;%0A%20%20%20%20subgraph%20cluster_main%20%7B%0A%20%20%20%20%20%20%20%20label%20=%20%22main%22;%0A%20%20%20%20%20%20%20%20main0%20-%3E%20main1;%0A%20%20%20%20%20%20%20%20main0%20%5Blabel%20=%20s0%5D;%0A%20%20%20%20%20%20%20%20main1%20%5Blabel%20=%20s1%5D;%0A%20%20%20%20%7D%0A%20%20%20%20subgraph%20cluster_t1%20%7B%0A%20%20%20%20%20%20%20%20label%20=%20%22t1%22;%0A%20%20%20%20%20%20%20%20main0%20-%3E%20t10;%0A%20%20%20%20%20%20%20%20t10%20%5Blabel%20=%20s2%5D;%0A%20%20%20%20%7D%0A%7D" alt=""/>
</p>
</div>
</div><div class="slide" data-transition="none"><div class="content graph_example segmentation_graph" ref="4_d2/3_algorithm/5_segmentation_graph/9">
<h2>Example #8</h2>

<p><code>main</code> starts <code>t2</code>; <code>main</code> and <code>t2</code> get new segments</p>

<pre class="sh_cpp"><code>    thread t1([] {});
    thread t2([] {
        // ...
    });
    // ...</code></pre>

<p><img src="https://chart.googleapis.com/chart?cht=gv&amp;chl=digraph%20%7B%0A%20%20%20%20graph%20%5Bbgcolor%20=%20transparent,%20splines%20=%20ortho%5D;%0A%20%20%20%20subgraph%20cluster_main%20%7B%0A%20%20%20%20%20%20%20%20label%20=%20%22main%22;%0A%20%20%20%20%20%20%20%20main0%20-%3E%20main1%20-%3E%20main2;%0A%20%20%20%20%20%20%20%20main0%20%5Blabel%20=%20s0%5D;%0A%20%20%20%20%20%20%20%20main1%20%5Blabel%20=%20s1%5D;%0A%20%20%20%20%20%20%20%20main2%20%5Blabel%20=%20s3%5D;%0A%20%20%20%20%7D%0A%20%20%20%20subgraph%20cluster_t1%20%7B%0A%20%20%20%20%20%20%20%20label%20=%20%22t1%22;%0A%20%20%20%20%20%20%20%20main0%20-%3E%20t10;%0A%20%20%20%20%20%20%20%20t10%20%5Blabel%20=%20s2%5D;%0A%20%20%20%20%7D%0A%20%20%20%20subgraph%20cluster_t2%20%7B%0A%20%20%20%20%20%20%20%20label%20=%20%22t2%22;%0A%20%20%20%20%20%20%20%20main1%20-%3E%20t20;%0A%20%20%20%20%20%20%20%20t20%20%5Blabel%20=%20s4%5D;%0A%20%20%20%20%7D%0A%7D" alt=""/>
</p>
</div>
</div><div class="slide" data-transition="none"><div class="content graph_example segmentation_graph" ref="4_d2/3_algorithm/5_segmentation_graph/10">
<h2>Example #8</h2>

<p><code>t2</code> starts <code>t3</code>; <code>t2</code> and <code>t3</code> get new segments</p>

<pre class="sh_cpp"><code>    thread t1([] {});
    thread t2([] {
        thread t3([] {});
        // ...
    });
    // ...</code></pre>

<p><img src="https://chart.googleapis.com/chart?cht=gv&amp;chl=digraph%20%7B%0A%20%20%20%20graph%20%5Bbgcolor%20=%20transparent,%20splines%20=%20ortho%5D;%0A%20%20%20%20subgraph%20cluster_main%20%7B%0A%20%20%20%20%20%20%20%20label%20=%20%22main%22;%0A%20%20%20%20%20%20%20%20main0%20-%3E%20main1%20-%3E%20main2;%0A%20%20%20%20%20%20%20%20main0%20%5Blabel%20=%20s0%5D;%0A%20%20%20%20%20%20%20%20main1%20%5Blabel%20=%20s1%5D;%0A%20%20%20%20%20%20%20%20main2%20%5Blabel%20=%20s3%5D;%0A%20%20%20%20%7D%0A%20%20%20%20subgraph%20cluster_t1%20%7B%0A%20%20%20%20%20%20%20%20label%20=%20%22t1%22;%0A%20%20%20%20%20%20%20%20main0%20-%3E%20t10;%0A%20%20%20%20%20%20%20%20t10%20%5Blabel%20=%20s2%5D;%0A%20%20%20%20%7D%0A%20%20%20%20subgraph%20cluster_t2%20%7B%0A%20%20%20%20%20%20%20%20label%20=%20%22t2%22;%0A%20%20%20%20%20%20%20%20main1%20-%3E%20t20%20-%3E%20t21;%0A%20%20%20%20%20%20%20%20t20%20%5Blabel%20=%20s4%5D;%0A%20%20%20%20%20%20%20%20t21%20%5Blabel%20=%20s5%5D;%0A%20%20%20%20%7D%0A%20%20%20%20subgraph%20cluster_t3%20%7B%0A%20%20%20%20%20%20%20%20label%20=%20%22t3%22;%0A%20%20%20%20%20%20%20%20t20%20-%3E%20t30;%0A%20%20%20%20%20%20%20%20t30%20%5Blabel%20=%20s6%5D;%0A%20%20%20%20%7D%0A%7D" alt=""/>
</p>
</div>
</div><div class="slide" data-transition="none"><div class="content graph_example segmentation_graph" ref="4_d2/3_algorithm/5_segmentation_graph/11">
<h2>Example #8</h2>

<p><code>t2</code> joins <code>t3</code>; <code>t2</code> continues in a new segment</p>

<pre class="sh_cpp"><code>    thread t1([] {});
    thread t2([] {
        thread t3([] {});
        t3.join();
    });
    // ...</code></pre>

<p><img src="https://chart.googleapis.com/chart?cht=gv&amp;chl=digraph%20%7B%0A%20%20%20%20graph%20%5Bbgcolor%20=%20transparent,%20splines%20=%20ortho%5D;%0A%20%20%20%20subgraph%20cluster_main%20%7B%0A%20%20%20%20%20%20%20%20label%20=%20%22main%22;%0A%20%20%20%20%20%20%20%20main0%20-%3E%20main1%20-%3E%20main2;%0A%20%20%20%20%20%20%20%20main0%20%5Blabel%20=%20s0%5D;%0A%20%20%20%20%20%20%20%20main1%20%5Blabel%20=%20s1%5D;%0A%20%20%20%20%20%20%20%20main2%20%5Blabel%20=%20s3%5D;%0A%20%20%20%20%7D%0A%20%20%20%20subgraph%20cluster_t1%20%7B%0A%20%20%20%20%20%20%20%20label%20=%20%22t1%22;%0A%20%20%20%20%20%20%20%20main0%20-%3E%20t10;%0A%20%20%20%20%20%20%20%20t10%20%5Blabel%20=%20s2%5D;%0A%20%20%20%20%7D%0A%20%20%20%20subgraph%20cluster_t2%20%7B%0A%20%20%20%20%20%20%20%20label%20=%20%22t2%22;%0A%20%20%20%20%20%20%20%20main1%20-%3E%20t20%20-%3E%20t21%20-%3E%20t22;%0A%20%20%20%20%20%20%20%20t20%20%5Blabel%20=%20s4%5D;%0A%20%20%20%20%20%20%20%20t21%20%5Blabel%20=%20s5%5D;%0A%20%20%20%20%20%20%20%20t22%20%5Blabel%20=%20s7%5D;%0A%20%20%20%20%7D%0A%20%20%20%20subgraph%20cluster_t3%20%7B%0A%20%20%20%20%20%20%20%20label%20=%20%22t3%22;%0A%20%20%20%20%20%20%20%20t20%20-%3E%20t30%20-%3E%20t22;%0A%20%20%20%20%20%20%20%20t30%20%5Blabel%20=%20s6%5D;%0A%20%20%20%20%7D%0A%7D" alt=""/>
</p>
</div>
</div><div class="slide" data-transition="none"><div class="content graph_example segmentation_graph" ref="4_d2/3_algorithm/5_segmentation_graph/12">
<h2>Example #8</h2>

<p><code>main</code> joins <code>t1</code>; <code>main</code> continues in a new segment</p>

<pre class="sh_cpp"><code>    thread t1([] {});
    thread t2([] {
        thread t3([] {});
        t3.join();
    });
    t1.join();
    // ...</code></pre>

<p><img src="https://chart.googleapis.com/chart?cht=gv&amp;chl=digraph%20%7B%0A%20%20%20%20graph%20%5Bbgcolor%20=%20transparent,%20splines%20=%20ortho%5D;%0A%20%20%20%20subgraph%20cluster_main%20%7B%0A%20%20%20%20%20%20%20%20label%20=%20%22main%22;%0A%20%20%20%20%20%20%20%20main0%20-%3E%20main1%20-%3E%20main2%20-%3E%20main3;%0A%20%20%20%20%20%20%20%20main0%20%5Blabel%20=%20s0%5D;%0A%20%20%20%20%20%20%20%20main1%20%5Blabel%20=%20s1%5D;%0A%20%20%20%20%20%20%20%20main2%20%5Blabel%20=%20s3%5D;%0A%20%20%20%20%20%20%20%20main3%20%5Blabel%20=%20s8%5D;%0A%20%20%20%20%7D%0A%20%20%20%20subgraph%20cluster_t1%20%7B%0A%20%20%20%20%20%20%20%20label%20=%20%22t1%22;%0A%20%20%20%20%20%20%20%20main0%20-%3E%20t10%20-%3E%20main3;%0A%20%20%20%20%20%20%20%20t10%20%5Blabel%20=%20s2%5D;%0A%20%20%20%20%7D%0A%20%20%20%20subgraph%20cluster_t2%20%7B%0A%20%20%20%20%20%20%20%20label%20=%20%22t2%22;%0A%20%20%20%20%20%20%20%20main1%20-%3E%20t20%20-%3E%20t21%20-%3E%20t22;%0A%20%20%20%20%20%20%20%20t20%20%5Blabel%20=%20s4%5D;%0A%20%20%20%20%20%20%20%20t21%20%5Blabel%20=%20s5%5D;%0A%20%20%20%20%20%20%20%20t22%20%5Blabel%20=%20s7%5D;%0A%20%20%20%20%7D%0A%20%20%20%20subgraph%20cluster_t3%20%7B%0A%20%20%20%20%20%20%20%20label%20=%20%22t3%22;%0A%20%20%20%20%20%20%20%20t20%20-%3E%20t30%20-%3E%20t22;%0A%20%20%20%20%20%20%20%20t30%20%5Blabel%20=%20s6%5D;%0A%20%20%20%20%7D%0A%7D" alt=""/>
</p>
</div>
</div><div class="slide" data-transition="none"><div class="content graph_example source_code_230P segmentation_graph" ref="4_d2/3_algorithm/5_segmentation_graph/13">
<h2>Example #8</h2>

<p><code>main</code> joins <code>t2</code>; <code>main</code> continues in a new segment</p>

<pre class="sh_cpp"><code>    thread t1([] {});
    thread t2([] {
        thread t3([] {});
        t3.join();
    });
    t1.join();
    t2.join();</code></pre>

<p><img src="https://chart.googleapis.com/chart?cht=gv&amp;chl=digraph%20%7B%0A%20%20%20%20graph%20%5Bbgcolor%20=%20transparent,%20splines%20=%20ortho%5D;%0A%20%20%20%20subgraph%20cluster_main%20%7B%0A%20%20%20%20%20%20%20%20label%20=%20%22main%22;%0A%20%20%20%20%20%20%20%20main0%20-%3E%20main1%20-%3E%20main2%20-%3E%20main3%20-%3E%20main4;%0A%20%20%20%20%20%20%20%20main0%20%5Blabel%20=%20s0%5D;%0A%20%20%20%20%20%20%20%20main1%20%5Blabel%20=%20s1%5D;%0A%20%20%20%20%20%20%20%20main2%20%5Blabel%20=%20s3%5D;%0A%20%20%20%20%20%20%20%20main3%20%5Blabel%20=%20s8%5D;%0A%20%20%20%20%20%20%20%20main4%20%5Blabel%20=%20s9%5D;%0A%20%20%20%20%7D%0A%20%20%20%20subgraph%20cluster_t1%20%7B%0A%20%20%20%20%20%20%20%20label%20=%20%22t1%22;%0A%20%20%20%20%20%20%20%20main0%20-%3E%20t10%20-%3E%20main3;%0A%20%20%20%20%20%20%20%20t10%20%5Blabel%20=%20s2%5D;%0A%20%20%20%20%7D%0A%20%20%20%20subgraph%20cluster_t2%20%7B%0A%20%20%20%20%20%20%20%20label%20=%20%22t2%22;%0A%20%20%20%20%20%20%20%20main1%20-%3E%20t20%20-%3E%20t21%20-%3E%20t22%20-%3E%20main4;%0A%20%20%20%20%20%20%20%20t20%20%5Blabel%20=%20s4%5D;%0A%20%20%20%20%20%20%20%20t21%20%5Blabel%20=%20s5%5D;%0A%20%20%20%20%20%20%20%20t22%20%5Blabel%20=%20s7%5D;%0A%20%20%20%20%7D%0A%20%20%20%20subgraph%20cluster_t3%20%7B%0A%20%20%20%20%20%20%20%20label%20=%20%22t3%22;%0A%20%20%20%20%20%20%20%20t20%20-%3E%20t30%20-%3E%20t22;%0A%20%20%20%20%20%20%20%20t30%20%5Blabel%20=%20s6%5D;%0A%20%20%20%20%7D%0A%7D" alt=""/>
</p>
</div>
</div><div class="slide" data-transition="none"><div class="content" ref="4_d2/3_algorithm/6_lock_graph_with_segments/1">
<p>Let's augment the lock graph by recording the segment in which an acquire is
made.</p>

<p>A cycle is not valid if any edge in the cycle happens before another edge in
the cycle.</p>
</div>
</div><div class="slide" data-transition="none"><div class="content graph_example lock_graph_with_segments" ref="4_d2/3_algorithm/6_lock_graph_with_segments/2">
<p>Let's go back to our false positive:</p>

<pre class="sh_cpp"><code>    mutex A, B;
    thread t1([&amp;] {
        A.lock();
        B.lock();
    });
    t1.join();

    thread t2([&amp;] {
        B.lock();
        A.lock();
    });</code></pre>
</div>
</div><div class="slide" data-transition="none">
  <div class="content graph_example lock_graph_with_segments" ref="4_d2/3_algorithm/6_lock_graph_with_segments/3">
<h2><code>main</code> starts in segment 0</h2>

<pre class="sh_cpp"><code>    mutex A, B;</code></pre>

<p><img src="https://chart.googleapis.com/chart?cht=gv&amp;chl=digraph%20%7B%0A%20%20%20%20label%20=%20%22segmentation%20graph%22;%0A%20%20%20%20graph%20%5Bsplines%20=%20ortho,%20bgcolor%20=%20transparent%5D;%0A%20%20%20%20subgraph%20cluster_main%20%7B%0A%20%20%20%20%20%20%20%20label%20=%20%22main%22;%0A%20%20%20%20%20%20%20%20main0%20%5Blabel%20=%20s0%5D;%0A%20%20%20%20%7D%0A%7D" alt=""/>

<p><img src="https://chart.googleapis.com/chart?cht=gv&amp;chl=digraph%20%7B%0A%20%20%20%20label%20=%20%22lock%20graph%22;%0A%20%20%20%20graph%20%5Bbgcolor%20=%20transparent%5D;%0A%20%20%20%20A;%20B;%0A%7D" alt=""/>
</p>
</p>
</div>
</div><div class="slide" data-transition="none">
  <div class="content graph_example lock_graph_with_segments" ref="4_d2/3_algorithm/6_lock_graph_with_segments/4">
<h2><code>main</code> starts <code>t1</code>; <code>main</code> and <code>t1</code> get new segments</h2>

<pre class="sh_cpp"><code>    mutex A, B;
    thread t1([&amp;] {
        // ...
    });</code></pre>

<p><img src="https://chart.googleapis.com/chart?cht=gv&amp;chl=digraph%20%7B%0A%20%20%20%20label%20=%20%22segmentation%20graph%22;%0A%20%20%20%20graph%20%5Bsplines%20=%20ortho,%20bgcolor%20=%20transparent%5D;%0A%20%20%20%20subgraph%20cluster_main%20%7B%0A%20%20%20%20%20%20%20%20label%20=%20%22main%22;%0A%20%20%20%20%20%20%20%20main0%20-%3E%20main1;%0A%20%20%20%20%20%20%20%20main0%20%5Blabel%20=%20s0%5D;%0A%20%20%20%20%20%20%20%20main1%20%5Blabel%20=%20s1%5D;%0A%20%20%20%20%7D%0A%20%20%20%20subgraph%20cluster_t1%20%7B%0A%20%20%20%20%20%20%20%20label%20=%20%22t1%22;%0A%20%20%20%20%20%20%20%20main0%20-%3E%20t10;%0A%20%20%20%20%20%20%20%20t10%20%5Blabel%20=%20s2%5D;%0A%20%20%20%20%7D%0A%7D" alt=""/>

<p><img src="https://chart.googleapis.com/chart?cht=gv&amp;chl=digraph%20%7B%0A%20%20%20%20label%20=%20%22lock%20graph%22;%0A%20%20%20%20graph%20%5Bbgcolor%20=%20transparent%5D;%0A%20%20%20%20A;%20B;%0A%7D" alt=""/>
</p>
</p>
</div>
</div><div class="slide" data-transition="none">
  <div class="content graph_example lock_graph_with_segments" ref="4_d2/3_algorithm/6_lock_graph_with_segments/5">
<h2><code>t1</code> acquires <code>A</code> and then <code>B</code>, both in segment 2</h2>

<pre class="sh_cpp"><code>    mutex A, B;
    thread t1([&amp;] {
        A.lock();
        B.lock();
    });</code></pre>

<p><img src="https://chart.googleapis.com/chart?cht=gv&amp;chl=digraph%20%7B%0A%20%20%20%20label%20=%20%22segmentation%20graph%22;%0A%20%20%20%20graph%20%5Bsplines%20=%20ortho,%20bgcolor%20=%20transparent%5D;%0A%20%20%20%20subgraph%20cluster_main%20%7B%0A%20%20%20%20%20%20%20%20label%20=%20%22main%22;%0A%20%20%20%20%20%20%20%20main0%20-%3E%20main1;%0A%20%20%20%20%20%20%20%20main0%20%5Blabel%20=%20s0%5D;%0A%20%20%20%20%20%20%20%20main1%20%5Blabel%20=%20s1%5D;%0A%20%20%20%20%7D%0A%20%20%20%20subgraph%20cluster_t1%20%7B%0A%20%20%20%20%20%20%20%20label%20=%20%22t1%22;%0A%20%20%20%20%20%20%20%20main0%20-%3E%20t10;%0A%20%20%20%20%20%20%20%20t10%20%5Blabel%20=%20s2%5D;%0A%20%20%20%20%7D%0A%7D" alt=""/>

<p><img src="https://chart.googleapis.com/chart?cht=gv&amp;chl=digraph%20%7B%0A%20%20%20%20label%20=%20%22lock%20graph%22;%0A%20%20%20%20graph%20%5Bbgcolor%20=%20transparent,%20rankdir%20=%20LR%5D;%0A%20%20%20%20A;%20B;%0A%20%20%20%20A%20-%3E%20B%20%5Blabel%20=%20%22t1%20:%20B%20in%20s2%20:%20%7BA%20in%20s2%7D%22%5D;%0A%7D" alt=""/>
</p>
</p>
</div>
</div><div class="slide" data-transition="none">
  <div class="content graph_example lock_graph_with_segments" ref="4_d2/3_algorithm/6_lock_graph_with_segments/6">
<h2><code>main</code> joins <code>t1</code>; <code>main</code> continues in a new segment</h2>

<pre class="sh_cpp"><code>    mutex A, B;
    thread t1([&amp;] {
        A.lock();
        B.lock();
    });
    t1.join();</code></pre>

<p><img src="https://chart.googleapis.com/chart?cht=gv&amp;chl=digraph%20%7B%0A%20%20%20%20label%20=%20%22segmentation%20graph%22;%0A%20%20%20%20graph%20%5Bsplines%20=%20ortho,%20bgcolor%20=%20transparent%5D;%0A%20%20%20%20subgraph%20cluster_main%20%7B%0A%20%20%20%20%20%20%20%20label%20=%20%22main%22;%0A%20%20%20%20%20%20%20%20main0%20-%3E%20main1%20-%3E%20main2;%0A%20%20%20%20%20%20%20%20main0%20%5Blabel%20=%20s0%5D;%0A%20%20%20%20%20%20%20%20main1%20%5Blabel%20=%20s1%5D;%0A%20%20%20%20%20%20%20%20main2%20%5Blabel%20=%20s3%5D;%0A%20%20%20%20%7D%0A%20%20%20%20subgraph%20cluster_t1%20%7B%0A%20%20%20%20%20%20%20%20label%20=%20%22t1%22;%0A%20%20%20%20%20%20%20%20main0%20-%3E%20t10%20-%3E%20main2;%0A%20%20%20%20%20%20%20%20t10%20%5Blabel%20=%20s2%5D;%0A%20%20%20%20%7D%0A%7D" alt=""/>

<p><img src="https://chart.googleapis.com/chart?cht=gv&amp;chl=digraph%20%7B%0A%20%20%20%20label%20=%20%22lock%20graph%22;%0A%20%20%20%20graph%20%5Bbgcolor%20=%20transparent,%20rankdir%20=%20LR%5D;%0A%20%20%20%20A;%20B;%0A%20%20%20%20A%20-%3E%20B%20%5Blabel%20=%20%22t1%20:%20B%20in%20s2%20:%20%7BA%20in%20s2%7D%22%5D;%0A%7D" alt=""/>
</p>
</p>
</div>
</div><div class="slide" data-transition="none">
  <div class="content graph_example lock_graph_with_segments source_code_230P" ref="4_d2/3_algorithm/6_lock_graph_with_segments/7">
<h2><code>main</code> starts <code>t2</code>; <code>main</code> and <code>t2</code> get new segments</h2>

<pre class="sh_cpp"><code>    mutex A, B;
    thread t1([&amp;] {
        A.lock();
        B.lock();
    });
    t1.join();

    thread t2([&amp;] {
        // ...
    });</code></pre>

<p><img src="https://chart.googleapis.com/chart?cht=gv&amp;chl=digraph%20%7B%0A%20%20%20%20label%20=%20%22segmentation%20graph%22;%0A%20%20%20%20graph%20%5Bsplines%20=%20ortho,%20bgcolor%20=%20transparent%5D;%0A%20%20%20%20subgraph%20cluster_main%20%7B%0A%20%20%20%20%20%20%20%20label%20=%20%22main%22;%0A%20%20%20%20%20%20%20%20main0%20-%3E%20main1%20-%3E%20main2%20-%3E%20main3;%0A%20%20%20%20%20%20%20%20main0%20%5Blabel%20=%20s0%5D;%0A%20%20%20%20%20%20%20%20main1%20%5Blabel%20=%20s1%5D;%0A%20%20%20%20%20%20%20%20main2%20%5Blabel%20=%20s3%5D;%0A%20%20%20%20%20%20%20%20main3%20%5Blabel%20=%20s5%5D;%0A%20%20%20%20%7D%0A%20%20%20%20subgraph%20cluster_t1%20%7B%0A%20%20%20%20%20%20%20%20label%20=%20%22t1%22;%0A%20%20%20%20%20%20%20%20main0%20-%3E%20t10%20-%3E%20main2;%0A%20%20%20%20%20%20%20%20t10%20%5Blabel%20=%20s2%5D;%0A%20%20%20%20%7D%0A%20%20%20%20subgraph%20cluster_t2%20%7B%0A%20%20%20%20%20%20%20%20label%20=%20%22t2%22;%0A%20%20%20%20%20%20%20%20main2%20-%3E%20t20;%0A%20%20%20%20%20%20%20%20t20%20%5Blabel%20=%20s4%5D;%0A%20%20%20%20%7D%0A%7D" alt=""/>

<p><img src="https://chart.googleapis.com/chart?cht=gv&amp;chl=digraph%20%7B%0A%20%20%20%20label%20=%20%22lock%20graph%22;%0A%20%20%20%20graph%20%5Bbgcolor%20=%20transparent,%20rankdir%20=%20LR%5D;%0A%20%20%20%20A;%20B;%0A%20%20%20%20A%20-%3E%20B%20%5Blabel%20=%20%22t1%20:%20B%20in%20s2%20:%20%7BA%20in%20s2%7D%22%5D;%0A%7D" alt=""/>
</p>
</p>
</div>
</div><div class="slide" data-transition="none">
  <div class="content graph_example lock_graph_with_segments source_code_230P" ref="4_d2/3_algorithm/6_lock_graph_with_segments/8">
<h2><code>t2</code> locks <code>B</code> and then <code>A</code>, both in segment 4</h2>

<pre class="sh_cpp"><code>    mutex A, B;
    thread t1([&amp;] {
        A.lock();
        B.lock();
    });
    t1.join();

    thread t2([&amp;] {
        B.lock();
        A.lock();
    });</code></pre>

<p><img src="https://chart.googleapis.com/chart?cht=gv&amp;chl=digraph%20%7B%0A%20%20%20%20label%20=%20%22segmentation%20graph%22;%0A%20%20%20%20graph%20%5Bsplines%20=%20ortho,%20bgcolor%20=%20transparent%5D;%0A%20%20%20%20subgraph%20cluster_main%20%7B%0A%20%20%20%20%20%20%20%20label%20=%20%22main%22;%0A%20%20%20%20%20%20%20%20main0%20-%3E%20main1%20-%3E%20main2%20-%3E%20main3;%0A%20%20%20%20%20%20%20%20main0%20%5Blabel%20=%20s0%5D;%0A%20%20%20%20%20%20%20%20main1%20%5Blabel%20=%20s1%5D;%0A%20%20%20%20%20%20%20%20main2%20%5Blabel%20=%20s3%5D;%0A%20%20%20%20%20%20%20%20main3%20%5Blabel%20=%20s5%5D;%0A%20%20%20%20%7D%0A%20%20%20%20subgraph%20cluster_t1%20%7B%0A%20%20%20%20%20%20%20%20label%20=%20%22t1%22;%0A%20%20%20%20%20%20%20%20main0%20-%3E%20t10%20-%3E%20main2;%0A%20%20%20%20%20%20%20%20t10%20%5Blabel%20=%20s2%5D;%0A%20%20%20%20%7D%0A%20%20%20%20subgraph%20cluster_t2%20%7B%0A%20%20%20%20%20%20%20%20label%20=%20%22t2%22;%0A%20%20%20%20%20%20%20%20main2%20-%3E%20t20;%0A%20%20%20%20%20%20%20%20t20%20%5Blabel%20=%20s4%5D;%0A%20%20%20%20%7D%0A%7D" alt=""/>

<p><img src="https://chart.googleapis.com/chart?cht=gv&amp;chl=digraph%20%7B%0A%20%20%20%20label%20=%20%22lock%20graph%22;%0A%20%20%20%20graph%20%5Bbgcolor%20=%20transparent,%20rankdir%20=%20LR%5D;%0A%20%20%20%20A;%20B;%0A%20%20%20%20A%20-%3E%20B%20%5Blabel%20=%20%22t1%20:%20B%20in%20s2%20:%20%7BA%20in%20s2%7D%22%5D;%0A%20%20%20%20B%20-%3E%20A%20%5Blabel%20=%20%22t2%20:%20A%20in%20s4%20:%20%7BB%20in%20s4%7D%22%5D;%0A%7D" alt=""/>
</p>
</p>
</div>
</div><div class="slide" data-transition="none">
  <div class="content graph_example lock_graph_with_segments source_code_230P" ref="4_d2/3_algorithm/6_lock_graph_with_segments/9">
<h2><code>main</code> joins <code>t2</code>; <code>main</code> continues in a new segment</h2>

<pre class="sh_cpp"><code>    mutex A, B;
    thread t1([&amp;] {
        A.lock();
        B.lock();
    });
    t1.join();

    thread t2([&amp;] {
        B.lock();
        A.lock();
    });
    t2.join();</code></pre>

<p><img src="https://chart.googleapis.com/chart?cht=gv&amp;chl=digraph%20%7B%0A%20%20%20%20label%20=%20%22segmentation%20graph%22;%0A%20%20%20%20graph%20%5Bsplines%20=%20ortho,%20bgcolor%20=%20transparent%5D;%0A%20%20%20%20subgraph%20cluster_main%20%7B%0A%20%20%20%20%20%20%20%20label%20=%20%22main%22;%0A%20%20%20%20%20%20%20%20main0%20-%3E%20main1%20-%3E%20main2%20-%3E%20main3%20-%3E%20main4;%0A%20%20%20%20%20%20%20%20main0%20%5Blabel%20=%20s0%5D;%0A%20%20%20%20%20%20%20%20main1%20%5Blabel%20=%20s1%5D;%0A%20%20%20%20%20%20%20%20main2%20%5Blabel%20=%20s3%5D;%0A%20%20%20%20%20%20%20%20main3%20%5Blabel%20=%20s5%5D;%0A%20%20%20%20%20%20%20%20main4%20%5Blabel%20=%20s6%5D;%0A%20%20%20%20%7D%0A%20%20%20%20subgraph%20cluster_t1%20%7B%0A%20%20%20%20%20%20%20%20label%20=%20%22t1%22;%0A%20%20%20%20%20%20%20%20main0%20-%3E%20t10%20-%3E%20main2;%0A%20%20%20%20%20%20%20%20t10%20%5Blabel%20=%20s2%5D;%0A%20%20%20%20%7D%0A%20%20%20%20subgraph%20cluster_t2%20%7B%0A%20%20%20%20%20%20%20%20label%20=%20%22t2%22;%0A%20%20%20%20%20%20%20%20main2%20-%3E%20t20%20-%3E%20main4;%0A%20%20%20%20%20%20%20%20t20%20%5Blabel%20=%20s4%5D;%0A%20%20%20%20%7D%0A%7D" alt=""/>

<p><img src="https://chart.googleapis.com/chart?cht=gv&amp;chl=digraph%20%7B%0A%20%20%20%20label%20=%20%22lock%20graph%22;%0A%20%20%20%20graph%20%5Bbgcolor%20=%20transparent,%20rankdir%20=%20LR%5D;%0A%20%20%20%20A;%20B;%0A%20%20%20%20A%20-%3E%20B%20%5Blabel%20=%20%22t1%20:%20B%20in%20s2%20:%20%7BA%20in%20s2%7D%22%5D;%0A%20%20%20%20B%20-%3E%20A%20%5Blabel%20=%20%22t2%20:%20A%20in%20s4%20:%20%7BB%20in%20s4%7D%22%5D;%0A%7D" alt=""/>
</p>
</p>
</div>
</div><div class="slide" data-transition="none"><div class="content" ref="4_d2/3_algorithm/6_lock_graph_with_segments/10">
<p>The cycle will be ignored because segment 2 happens before segment 4.</p>
</div>
</div><div class="slide" data-transition="none"><div class="content" ref="4_d2/3_algorithm/7_summary/1">
<h1>Summary of the algorithm</h1>
</div>
</div><div class="slide" data-transition="none"><div class="content smbullets" ref="4_d2/3_algorithm/7_summary/2">
<h2>The lock graph is a directed multigraph</h2>

<ul>
<li>Vertices represent synchronization objects</li>
<li>An edge from <code>u</code> to <code>v</code> means that a thread acquired <code>v</code> while holding <code>u</code></li>
<li>A cycle in the graph represents a potential deadlock</li>
</ul>
</div>
</div><div class="slide" data-transition="none"><div class="content smbullets" ref="4_d2/3_algorithm/7_summary/3">
<h2>The segmentation graph is a directed acyclic graph</h2>

<ul>
<li>Vertices represent segments of code separated by <code>start</code>s and <code>join</code>s</li>
<li>A path from <code>u</code> to <code>v</code> means that <code>u</code> happens before <code>v</code></li>
</ul>
</div>
</div><div class="slide" data-transition="none"><div class="content smbullets" ref="4_d2/3_algorithm/7_summary/4">
<h2>We label each edge of the lock graph with</h2>

<ul>
<li>The thread that performed the acquire</li>
<li>The set of locks held by the thread ("gatelocks")</li>
<li>The code segment in which the acquire is performed</li>
</ul>
</div>
</div><div class="slide" data-transition="none"><div class="content" ref="4_d2/3_algorithm/7_summary/5">
<h2>To reduce false positives, we ignore a cycle if...</h2>
</div>
</div><div class="slide" data-transition="none"><div class="content small" ref="4_d2/3_algorithm/7_summary/6">
<h2>Any two edges are in the same thread</h2>

<pre class="sh_cpp"><code>    mutex A, B;
    thread t1([&amp;] {
      A.lock();
        B.lock();
        B.unlock();
      A.unlock();

      B.lock();
        A.lock();
        A.unlock();
      B.unlock();
    });</code></pre>
</div>
</div><div class="slide" data-transition="none"><div class="content small" ref="4_d2/3_algorithm/7_summary/7">
<h2>Any two edges share common "gatelocks"</h2>

<pre class="sh_cpp"><code>    mutex A, B, G;
    thread t1([&amp;] {
      G.lock();
        A.lock();
          B.lock();
          B.unlock();
        A.unlock();
      G.unlock();
    });

    thread t2([&amp;] {
      G.lock();
        B.lock();
          A.lock();
          A.unlock();
        B.unlock();
      G.unlock();
    });</code></pre>
</div>
</div><div class="slide" data-transition="none"><div class="content small" ref="4_d2/3_algorithm/7_summary/8">
<h2>Any edge happens before any other edge in the cycle</h2>

<pre class="sh_cpp"><code>    mutex A, B;
    thread t1([&amp;] {
      A.lock();
        B.lock();
        B.unlock();
      A.unlock();
    });
    t1.join();

    thread t2([&amp;] {
      B.lock();
        A.lock();
        A.unlock();
      B.unlock();
    });</code></pre>
</div>
</div><div class="slide" data-transition="none"><div class="content smbullets incremental" ref="4_d2/4_roadmap/1">
<h1>Limitations and drawbacks</h1>

<ul>
<li>Requires modifying existing code</li>
<li>No integration with an IDE</li>
<li>Current implementation is immature</li>
</ul>
</div>
</div><div class="slide" data-transition="none"><div class="content smbullets incremental" ref="4_d2/4_roadmap/2">
<h1>Roadmap</h1>

<ul>
<li>Support a wider set of synchronization primitives</li>
<li>Provide integration with more libraries</li>
<li>Reduce false positives further (I have some ideas)</li>
</ul>
</div>
</div><div class="slide" data-transition="none"><div class="content commandline" ref="4_d2/4_roadmap/3">
<p class="notes">Right now, the integration is only with pthreads because I lack access
to a windows machine.</p>

<h2>Want to try it?</h2>

<pre><code><code class="command">$ cd ${boost_root}</code>
<code class="result">
</code><code class="command">$ patch -p1 &lt; ${d2_root}/integrations/boost/1_53_00.diff</code>
<code class="result">
</code><code class="command">$ ./bjam -j64 # :)</code>
</code></pre>
</div>
</div><div class="slide" data-transition="none"><div class="content subsection small" ref="5_dyno/1">
<h1><code>dyno</code>: a DSEL for dynamic analysis</h1>
</div>
</div><div class="slide" data-transition="none"><div class="content" ref="5_dyno/2">
<h2>This is <strong>very</strong> experimental, so we won't go in depth</h2>
</div>
</div><div class="slide" data-transition="none"><div class="content" ref="5_dyno/3">
<h1>Idea</h1>

<ul>
<li>Events are generated by a program and recorded</li>
<li>Custom actions can be bound to these events</li>
<li>Events can be loaded conveniently to analyze a program trace</li>
<li>Use a DSEL to make it easy</li>
</ul>
</div>
</div><div class="slide" data-transition="none"><div class="content small" ref="5_dyno/4">
<h2>First, define an event</h2>

<pre class="sh_cpp"><code>    namespace tags {
      struct acquire;
      struct lock_id;
    }

    typedef event&lt;tags::acquire,
              records&lt;call_stack&gt;,
              records&lt;thread_id&gt;,
              records&lt;
               custom_info&lt;tags::lock_id, unsigned&gt;
              &gt;
            &gt; acquire_event;</code></pre>
</div>
</div><div class="slide" data-transition="none"><div class="content small" ref="5_dyno/5">
<h2>Then, bundle the events into a <code>framework</code></h2>

<pre class="sh_cpp"><code>    typedef framework&lt;
              events&lt;
                acquire_event, release_event,
                start_event, join_event
              &gt;,
              backend&lt;save_on_filesystem&gt;
            &gt; d2_framework_t;

    static d2_framework_t d2_framework;</code></pre>
</div>
</div><div class="slide" data-transition="none"><div class="content small" ref="5_dyno/6">
<h2>Bind actions to events as wanted</h2>

<pre class="sh_cpp"><code>    dyno::on&lt;tags::acquire&gt;(d2_framework,
        [](acquire_event e) {
          // whatever
        });</code></pre>
</div>
</div><div class="slide" data-transition="none"><div class="content small" ref="5_dyno/7">
<h2>Generate events in your code</h2>

<pre class="sh_cpp"><code>    struct mutex {
      void lock() {
        dyno::generate&lt;tags::acquire&gt;(
                      d2_framework, *this);
      }
    };</code></pre>
</div>
</div><div class="slide" data-transition="none"><div class="content small" ref="5_dyno/8">
<h2>Load events from a source to perform your custom analysis without hassle</h2>

<pre class="sh_cpp"><code>    struct populate_lock_graph {
      void operator()(acquire_event e) const;
      void operator()(release_event e) const;

      template &lt;typename AnyOtherEvent&gt;
      void operator()(AnyOtherEvent) const;
    };

    dyno::load_events("some_directory",
                      populate_lock_graph());</code></pre>
</div>
</div><div class="slide" data-transition="none"><div class="content bullets incremental" ref="5_dyno/9">
<p class="notes">Explain how the project was started by witnessing that much of the
       code from d2 could be generally useful for dynamic analysis.</p>

<h1>Use cases</h1>

<ul>
<li>Simplifying the implementation of <code>d2</code></li>
<li>Benchmarking and checking memory allocations</li>
<li>Gathering statistics during program execution</li>
</ul>
</div>
</div><div class="slide" data-transition="none"><div class="content" ref="7_conclusion">
<h1>Questions/Comments?</h1>
</div>
</div></div>
<div id="pauseScreen">
  
</div>

</body>
</html>
