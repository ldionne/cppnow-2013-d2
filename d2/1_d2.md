<!SLIDE subsection>
# d2: a _d_eadlock _d_etector


<!SLIDE>
# Purpose and scope


<!SLIDE>
<!--
    present the API of the library, i.e. the lock concepts, mixins, etc...
    must also present how to integrate with existing thread classes, even
    though there is no easy way to do this currently
-->
# Empowering your code of this awesome tool

    @@@ cpp
        class mutex {
        public:
            void lock();
            void unlock();
        };


<!SLIDE>
# first way

    @@@ cpp
        class unchecked_mutex {
        public:
            void lock();
            void unlock();
        };

        typedef d2::basic_lockable<unchecked_mutex> mutex;


<!SLIDE>
# second way

    @@@ cpp
        class mutex : public d2::basic_lockable_mixin<mutex> {
            friend class d2::basic_lockable_mixin<mutex>;
            void lock_impl();
            void unlock_impl();
        };


<!SLIDE>
# 3rd way (if you really have to)

    @@@ cpp
        class mutex : private d2::trackable_sync_object<d2::non_recursive> {
        public:
            void lock() {
                // ...
                this->notify_lock();
            }

            void unlock() {
                // ...
                this->notify_unlock();
            }
        };


<!SLIDE commandline>
# but wait! if you happen to be using Boost...

    $ cd ${boost_root}

    $ patch . ${d2_root}/integrations/boost/1_53_00.patch

    $ ./bjam -j64 # hurry up!


<!SLIDE>
# d2 plays nicely with `Boost.Thread` concepts
* `boost::BasicLockable` and `d2::basic_lockable`
* `boost::Lockable` and `d2::lockable`
* `boost::TimedLockable` and `d2::timed_lockable`

.notes explain how each wrapper has a mixin counterpart to accomodate every use case.


<!SLIDE>
# ... and their recursive counterparts

    @@@ cpp
        d2::recursive_basic_lockable
        d2::recursive_lockable
        d2::recursive_timed_lockable

.notes explain how each wrapper has a recursive counterpart that is a simple shortcut for the longer version


<!SLIDE>
<!--
    give a bird's eye view of the large components. explain the high level
    flow of the events from the application to the repository, and then
    how the repository is analyzed with an utility post-mortem.
-->
# Overall design


<!SLIDE>
<!--
    present the actual algorithm. begin with the basic goodlock algorithm,
    and then extend it to several threads. then, present the final version
    filtering some false positives, as presented in the IBM paper.
-->
# The algorithm


<!SLIDE>
<!--
    this is a _MUST_. seriously. I also need to show benchmarks with and
    without the logging enabled, to show that the impact on performance is
    not too large (which is not the case currently!).
-->
# Real world examples


<!SLIDE>
# Limitations

<!--
    - types of deadlocks we know we don't currently detect
    - types of deadlocks we won't even try to detect since it would escape
      the scope of the project
    - difficulty of having meaningful diagnostic information (stack traces)
      efficiently, and difficulty to have them at all without debug symbols
    - potential scalability problems with the algorithm
-->


<!SLIDE bullets>
# Roadmap

<!-- also talk about generalizing to more than locks, but any resource -->
* Support more varieties of locks

* Detect more types of deadlocks

<!-- talk about efficient call stacks -->
* Provide meaningful diagnostics

<!-- mention at least TBB -->
* Provide integration with more libraries

<!--
    the ultimate goal is to be able to define orthogonal dynamic analysis
    tools using a DSEL. uses cases are:
        - benchmarking/checking memory allocation
        - access to shared variables to detect race conditions (this might be
          impossible because it would require too much modification)
        - gather statistics during program execution
-->
* Create a generic toolbox to ease intrusive dynamic analysis (dyno)
