<!SLIDE subsection>
# d2: a _d_eadlock _d_etector


<!SLIDE bullets>
# Purpose and scope

* locking order inconsistencies between N threads
* single process, non-distributed programs
* supports custom locks and threads
* few false positives


<!SLIDE>
<!--
    give a bird's eye view of the large components. explain the high level
    flow of the events from the application to the repository, and then
    how the repository is analyzed with an utility post-mortem.
-->
# Design


<!SLIDE>
## concepts from Boost.Thread

    @@@ cpp
        boost::BasicLockable
        boost::Lockable
        boost::TimedLockable


<!SLIDE>
## high level concept based API

    @@@ cpp
        d2::basic_lockable
        d2::lockable
        d2::timed_lockable

.notes explain how each wrapper has a mixin counterpart to accomodate every use case.


<!SLIDE>
## with recursive flavors

    @@@ cpp
        d2::recursive_basic_lockable
        d2::recursive_lockable
        d2::recursive_timed_lockable

.notes explain how each wrapper has a recursive counterpart that is a simple shortcut for the longer version


<!SLIDE>
# low level C API (bindings someone?)

    @@@ c
        d2_notify_acquire(thread, lock)
        d2_notify_release(thread, lock)
        d2_notify_start(parent, child)
        d2_notify_join(parent, child)


<!SLIDE>
# event generation and dispatch to the filesystem

    @@@ cpp
        dispatch(core::acquire(thread, lock))
        dispatch(core::release(thread, lock))
        dispatch(core::start(parent, child))
        dispatch(core::join(parent, child))
        dispatch(core::segment_hop(thread, new_segment))


<!SLIDE>
# organization of events inside a directory

    <!-- here, have a picture or an example of a repository to show
         the directory structure (per-thread and global events)
    -->


<!SLIDE commandline>
# mumbo jumbo on disk

    $ cat my_program/1    # thread 1
    22 serialization::archive 10 0 0 4 0 0 0 0 1 0 0 2 0 0 0 0 0 1 0 0 0 0 0 0 0 0 0 0 1 1 0 0 1 0 0 1 1 0 0 1 1 0 0 0


<!SLIDE commandline>
# `d2tool` speaks that mumbo jumbo

    $ d2tool --analyze myprogram
    we're not done with the design yet :)
        <!--
            make this fade in. everyone will expect
            to see the output. I'm evil.
        -->


<!SLIDE>



<!SLIDE>
# empowering your code of this awesome tool

    @@@ cpp
        class mutex {
        public:
            void lock();
            void unlock();
        };


<!SLIDE>
# first way

    @@@ cpp
        class untracked_mutex {
        public:
            void lock();
            void unlock();
        };

        typedef d2::basic_lockable<untracked_mutex> mutex;


<!SLIDE>
# second way

    @@@ cpp
        class mutex : public d2::basic_lockable_mixin<mutex> {
            friend class d2::basic_lockable_mixin<mutex>;
            void lock_impl();
            void unlock_impl();
        };

.notes explain why this way exists (nested typedef representing the mutex type)


<!SLIDE>
# 3rd way (if you really have to)

    @@@ cpp
        class mutex : private d2::trackable_sync_object<d2::non_recursive> {
        public:
            void lock() {
                // ...
                this->notify_lock();
            }

            void unlock() {
                // ...
                this->notify_unlock();
            }
        };


<!SLIDE>
# tracking standard conforming threads

    @@@ cpp
        class untracked_thread {
            // ...
        };
        typedef d2::trackable_thread<untracked_thread> thread;


<!SLIDE>
# tracking threads with arbitrary implementations

    @@@ cpp
        class thread {
            d2::thread_lifetime lifetime_;

            // ...


<!SLIDE>
# thread birth

    @@@ cpp
        template <typename Function, typename ...Args>
        void start(Function&& f, Args&& ...args) {
            lifetime_.about_to_start();
            d2::thread_function<Function> f_(lifetime_, f);
            // start the thread with f_ instead of f
        }


<!SLIDE>
# letting go

    @@@ cpp
        void detach() {
            // ...
            lifetime_.just_detached();
        }


<!SLIDE>
# thread death

    @@@ cpp
        void join() {
            // ...
            lifetime_.just_joined();
        }


<!SLIDE commandline>
# everything is easier with Boost

    $ cd ${boost_root}

    $ patch . ${d2_root}/integrations/boost/1_53_00.patch

    $ ./bjam -j64 # :)


<!SLIDE>
<!--
    present the actual algorithm. begin with the basic goodlock algorithm,
    and then extend it to several threads. then, present the final version
    filtering some false positives, as presented in the IBM paper.
-->
# The algorithm


<!SLIDE>
<!--
    this is a _MUST_. seriously. I also need to show benchmarks with and
    without the logging enabled, to show that the impact on performance is
    not too large (which is not the case currently!).
-->
# Real world examples


<!SLIDE>
# Limitations

<!--
    - types of deadlocks we know we don't currently detect
    - types of deadlocks we won't even try to detect since it would escape
      the scope of the project
    - difficulty of having meaningful diagnostic information (stack traces)
      efficiently, and difficulty to have them at all without debug symbols
    - potential scalability problems with the algorithm
-->


<!SLIDE bullets>
# Roadmap

<!-- also talk about generalizing to more than locks, but any resource -->
* Support more varieties of locks

* Detect more types of deadlocks

<!-- talk about efficient call stacks -->
* Provide meaningful diagnostics

<!-- mention at least TBB -->
* Provide integration with more libraries

<!--
    the ultimate goal is to be able to define orthogonal dynamic analysis
    tools using a DSEL. uses cases are:
        - benchmarking/checking memory allocation
        - access to shared variables to detect race conditions (this might be
          impossible because it would require too much modification)
        - gather statistics during program execution
-->
* Create a generic toolbox to ease intrusive dynamic analysis (dyno)
